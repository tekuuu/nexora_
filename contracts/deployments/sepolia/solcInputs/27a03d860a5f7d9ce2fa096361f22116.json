{
  "language": "Solidity",
  "sources": {
    "@fhevm/solidity/config/ZamaConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {SepoliaZamaOracleAddress} from \"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\";\nimport {FHE} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {CoprocessorConfig} from \"@fhevm/solidity/lib/Impl.sol\";\n\n/**\n * @title   ZamaConfig.\n * @notice  This library returns the FHEVM config for different networks\n *          with the contract addresses for (1) ACL, (2) CoprocessorAddress, (3) DecryptionOracleAddress, (4) KMSVerifier,\n *          which are deployed & maintained by Zama. It also returns the address of the decryption oracle.\n */\nlibrary ZamaConfig {\n    function getSepoliaProtocolId() internal pure returns (uint256) {\n        /// @note Zama Ethereum Sepolia protocol id is '10000 + Zama Ethereum protocol id'\n        return 10001;\n    }\n\n    function getSepoliaConfig() internal pure returns (CoprocessorConfig memory) {\n        return\n            CoprocessorConfig({\n                ACLAddress: 0x50157CFfD6bBFA2DECe204a89ec419c23ef5755D,\n                CoprocessorAddress: 0xCD3ab3bd6bcc0c0bf3E27912a92043e817B1cf69,\n                DecryptionOracleAddress: SepoliaZamaOracleAddress,\n                KMSVerifierAddress: 0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC\n            });\n    }\n\n    function getEthereumProtocolId() internal pure returns (uint256) {\n        /// @note Zama Ethereum protocol id is '1'\n        return 1;\n    }\n\n    function getEthereumConfig() internal pure returns (CoprocessorConfig memory) {\n        /// @note The addresses below are placeholders and should be replaced with actual addresses\n        /// once deployed on the Ethereum mainnet.\n        return\n            CoprocessorConfig({\n                ACLAddress: address(0),\n                CoprocessorAddress: address(0),\n                DecryptionOracleAddress: address(0),\n                KMSVerifierAddress: address(0)\n            });\n    }\n}\n\n/**\n * @title   SepoliaConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Sepolia network (chainId = 11155111).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaConfig {\n    constructor() {\n        FHE.setCoprocessor(ZamaConfig.getSepoliaConfig());\n    }\n\n    function protocolId() public pure returns (uint256) {\n        return ZamaConfig.getSepoliaProtocolId();\n    }\n}\n\n/**\n * @title   EthereumConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumConfig {\n    constructor() {\n        FHE.setCoprocessor(ZamaConfig.getEthereumConfig());\n    }\n\n    function protocolId() public pure returns (uint256) {\n        return ZamaConfig.getEthereumProtocolId();\n    }\n}\n"
    },
    "@fhevm/solidity/lib/FHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./Impl.sol\";\nimport {FheType} from \"./FheType.sol\";\n\nimport \"encrypted-types/EncryptedTypes.sol\";\n\n/**\n * @title IKMSVerifier\n * @notice This interface contains the only function required from KMSVerifier.\n */\ninterface IKMSVerifier {\n    function verifyDecryptionEIP712KMSSignatures(\n        bytes32[] memory handlesList,\n        bytes memory decryptedResult,\n        bytes memory decryptionProof\n    ) external returns (bool);\n}\n\n/**\n * @title IDecryptionOracle\n * @notice This interface contains the only function required from DecryptionOracle.\n */\ninterface IDecryptionOracle {\n    function requestDecryption(\n        uint256 requestID,\n        bytes32[] calldata ctsHandles,\n        bytes4 callbackSelector\n    ) external payable;\n}\n\n/**\n * @title   FHE\n * @notice  This library is the interaction point for all smart contract developers\n *          that interact with the FHEVM protocol.\n */\nlibrary FHE {\n    /// @notice Returned if some handles were already saved for corresponding ID.\n    error HandlesAlreadySavedForRequestID();\n\n    /// @notice Returned if there was not handle found for the requested ID.\n    error NoHandleFoundForRequestID();\n\n    /// @notice Returned if the returned KMS signatures are not valid.\n    error InvalidKMSSignatures();\n\n    /// @notice This event is emitted when requested decryption has been fulfilled.\n    event DecryptionFulfilled(uint256 indexed requestID);\n\n    /**\n     * @notice                  Sets the coprocessor addresses.\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\n     */\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\n        Impl.setCoprocessor(coprocessorConfig);\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint64 v) internal pure returns (bool) {\n        return euint64.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint128 v) internal pure returns (bool) {\n        return euint128.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(eaddress v) internal pure returns (bool) {\n        return eaddress.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\n     */\n    function isInitialized(euint256 v) internal pure returns (bool) {\n        return euint256.unwrap(v) != 0;\n    }\n\n    /**\n     * @dev Evaluates and(ebool a, ebool b) and returns the result.\n     */\n    function and(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(ebool a, ebool b) and returns the result.\n     */\n    function or(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(ebool a, ebool b) and returns the result.\n     */\n    function xor(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(ebool a, ebool b) and returns the result.\n     */\n    function eq(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(ebool a, ebool b) and returns the result.\n     */\n    function ne(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint8 b)  and returns the result.\n     */\n    function add(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint8 b)  and returns the result.\n     */\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint8 b)  and returns the result.\n     */\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint8 b)  and returns the result.\n     */\n    function and(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint8 b)  and returns the result.\n     */\n    function or(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint8 b)  and returns the result.\n     */\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint8 b)  and returns the result.\n     */\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint8 b)  and returns the result.\n     */\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint8 b)  and returns the result.\n     */\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint8 b)  and returns the result.\n     */\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint8 b)  and returns the result.\n     */\n    function le(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint8 b)  and returns the result.\n     */\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint8 b)  and returns the result.\n     */\n    function min(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint8 b)  and returns the result.\n     */\n    function max(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint16 b)  and returns the result.\n     */\n    function add(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint16 b)  and returns the result.\n     */\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint16 b)  and returns the result.\n     */\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint16 b)  and returns the result.\n     */\n    function and(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint16 b)  and returns the result.\n     */\n    function or(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint16 b)  and returns the result.\n     */\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint16 b)  and returns the result.\n     */\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint16 b)  and returns the result.\n     */\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint16 b)  and returns the result.\n     */\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint16 b)  and returns the result.\n     */\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint16 b)  and returns the result.\n     */\n    function le(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint16 b)  and returns the result.\n     */\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint16 b)  and returns the result.\n     */\n    function min(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint16 b)  and returns the result.\n     */\n    function max(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint32 b)  and returns the result.\n     */\n    function add(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint32 b)  and returns the result.\n     */\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint32 b)  and returns the result.\n     */\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint32 b)  and returns the result.\n     */\n    function and(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint32 b)  and returns the result.\n     */\n    function or(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint32 b)  and returns the result.\n     */\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint32 b)  and returns the result.\n     */\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint32 b)  and returns the result.\n     */\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint32 b)  and returns the result.\n     */\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint32 b)  and returns the result.\n     */\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint32 b)  and returns the result.\n     */\n    function le(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint32 b)  and returns the result.\n     */\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint32 b)  and returns the result.\n     */\n    function min(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint32 b)  and returns the result.\n     */\n    function max(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint64 b)  and returns the result.\n     */\n    function add(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint64 b)  and returns the result.\n     */\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint64 b)  and returns the result.\n     */\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint64 b)  and returns the result.\n     */\n    function and(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint64 b)  and returns the result.\n     */\n    function or(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint64 b)  and returns the result.\n     */\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint64 b)  and returns the result.\n     */\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint64 b)  and returns the result.\n     */\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint64 b)  and returns the result.\n     */\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint64 b)  and returns the result.\n     */\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint64 b)  and returns the result.\n     */\n    function le(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint64 b)  and returns the result.\n     */\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint64 b)  and returns the result.\n     */\n    function min(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint64 b)  and returns the result.\n     */\n    function max(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, euint128 b)  and returns the result.\n     */\n    function add(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, euint128 b)  and returns the result.\n     */\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, euint128 b)  and returns the result.\n     */\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint128 b)  and returns the result.\n     */\n    function and(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint128 b)  and returns the result.\n     */\n    function or(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint128 b)  and returns the result.\n     */\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint128 b)  and returns the result.\n     */\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint128 b)  and returns the result.\n     */\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, euint128 b)  and returns the result.\n     */\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, euint128 b)  and returns the result.\n     */\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, euint128 b)  and returns the result.\n     */\n    function le(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, euint128 b)  and returns the result.\n     */\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, euint128 b)  and returns the result.\n     */\n    function min(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, euint128 b)  and returns the result.\n     */\n    function max(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, euint256 b)  and returns the result.\n     */\n    function and(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, euint256 b)  and returns the result.\n     */\n    function or(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, euint256 b)  and returns the result.\n     */\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, euint256 b)  and returns the result.\n     */\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, euint256 b)  and returns the result.\n     */\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint8 b)  and returns the result.\n     */\n    function add(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint8 b)  and returns the result.\n     */\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint8 b)  and returns the result.\n     */\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint8 b)  and returns the result.\n     */\n    function and(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint8 b)  and returns the result.\n     */\n    function or(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint8 b)  and returns the result.\n     */\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint8 b)  and returns the result.\n     */\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint8 b)  and returns the result.\n     */\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint8 b)  and returns the result.\n     */\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint8 b)  and returns the result.\n     */\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint8 b)  and returns the result.\n     */\n    function le(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint8 b)  and returns the result.\n     */\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint8 b)  and returns the result.\n     */\n    function min(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint8 b)  and returns the result.\n     */\n    function max(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint16 b)  and returns the result.\n     */\n    function add(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint16 b)  and returns the result.\n     */\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint16 b)  and returns the result.\n     */\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint16 b)  and returns the result.\n     */\n    function and(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint16 b)  and returns the result.\n     */\n    function or(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint16 b)  and returns the result.\n     */\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint16 b)  and returns the result.\n     */\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint16 b)  and returns the result.\n     */\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint16 b)  and returns the result.\n     */\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint16 b)  and returns the result.\n     */\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint16 b)  and returns the result.\n     */\n    function le(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint16 b)  and returns the result.\n     */\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint16 b)  and returns the result.\n     */\n    function min(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint16 b)  and returns the result.\n     */\n    function max(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint32 b)  and returns the result.\n     */\n    function add(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint32 b)  and returns the result.\n     */\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint32 b)  and returns the result.\n     */\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint32 b)  and returns the result.\n     */\n    function and(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint32 b)  and returns the result.\n     */\n    function or(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint32 b)  and returns the result.\n     */\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint32 b)  and returns the result.\n     */\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint32 b)  and returns the result.\n     */\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint32 b)  and returns the result.\n     */\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint32 b)  and returns the result.\n     */\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint32 b)  and returns the result.\n     */\n    function le(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint32 b)  and returns the result.\n     */\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint32 b)  and returns the result.\n     */\n    function min(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint32 b)  and returns the result.\n     */\n    function max(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint64 b)  and returns the result.\n     */\n    function add(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint64 b)  and returns the result.\n     */\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint64 b)  and returns the result.\n     */\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint64 b)  and returns the result.\n     */\n    function and(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint64 b)  and returns the result.\n     */\n    function or(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint64 b)  and returns the result.\n     */\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint64 b)  and returns the result.\n     */\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint64 b)  and returns the result.\n     */\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint64 b)  and returns the result.\n     */\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint64 b)  and returns the result.\n     */\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint64 b)  and returns the result.\n     */\n    function le(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint64 b)  and returns the result.\n     */\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint64 b)  and returns the result.\n     */\n    function min(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint64 b)  and returns the result.\n     */\n    function max(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, euint128 b)  and returns the result.\n     */\n    function add(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, euint128 b)  and returns the result.\n     */\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, euint128 b)  and returns the result.\n     */\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint128 b)  and returns the result.\n     */\n    function and(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint128 b)  and returns the result.\n     */\n    function or(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint128 b)  and returns the result.\n     */\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint128 b)  and returns the result.\n     */\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint128 b)  and returns the result.\n     */\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, euint128 b)  and returns the result.\n     */\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, euint128 b)  and returns the result.\n     */\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, euint128 b)  and returns the result.\n     */\n    function le(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, euint128 b)  and returns the result.\n     */\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, euint128 b)  and returns the result.\n     */\n    function min(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, euint128 b)  and returns the result.\n     */\n    function max(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, euint256 b)  and returns the result.\n     */\n    function and(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, euint256 b)  and returns the result.\n     */\n    function or(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, euint256 b)  and returns the result.\n     */\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, euint256 b)  and returns the result.\n     */\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, euint256 b)  and returns the result.\n     */\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint8 b)  and returns the result.\n     */\n    function add(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint8 b)  and returns the result.\n     */\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint8 b)  and returns the result.\n     */\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint8 b)  and returns the result.\n     */\n    function and(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint8 b)  and returns the result.\n     */\n    function or(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint8 b)  and returns the result.\n     */\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint8 b)  and returns the result.\n     */\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint8 b)  and returns the result.\n     */\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint8 b)  and returns the result.\n     */\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint8 b)  and returns the result.\n     */\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint8 b)  and returns the result.\n     */\n    function le(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint8 b)  and returns the result.\n     */\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint8 b)  and returns the result.\n     */\n    function min(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint8 b)  and returns the result.\n     */\n    function max(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint16 b)  and returns the result.\n     */\n    function add(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint16 b)  and returns the result.\n     */\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint16 b)  and returns the result.\n     */\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint16 b)  and returns the result.\n     */\n    function and(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint16 b)  and returns the result.\n     */\n    function or(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint16 b)  and returns the result.\n     */\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint16 b)  and returns the result.\n     */\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint16 b)  and returns the result.\n     */\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint16 b)  and returns the result.\n     */\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint16 b)  and returns the result.\n     */\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint16 b)  and returns the result.\n     */\n    function le(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint16 b)  and returns the result.\n     */\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint16 b)  and returns the result.\n     */\n    function min(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint16 b)  and returns the result.\n     */\n    function max(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint32 b)  and returns the result.\n     */\n    function add(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint32 b)  and returns the result.\n     */\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint32 b)  and returns the result.\n     */\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint32 b)  and returns the result.\n     */\n    function and(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint32 b)  and returns the result.\n     */\n    function or(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint32 b)  and returns the result.\n     */\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint32 b)  and returns the result.\n     */\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint32 b)  and returns the result.\n     */\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint32 b)  and returns the result.\n     */\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint32 b)  and returns the result.\n     */\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint32 b)  and returns the result.\n     */\n    function le(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint32 b)  and returns the result.\n     */\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint32 b)  and returns the result.\n     */\n    function min(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint32 b)  and returns the result.\n     */\n    function max(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint64 b)  and returns the result.\n     */\n    function add(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint64 b)  and returns the result.\n     */\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint64 b)  and returns the result.\n     */\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint64 b)  and returns the result.\n     */\n    function and(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint64 b)  and returns the result.\n     */\n    function or(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint64 b)  and returns the result.\n     */\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint64 b)  and returns the result.\n     */\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint64 b)  and returns the result.\n     */\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint64 b)  and returns the result.\n     */\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint64 b)  and returns the result.\n     */\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint64 b)  and returns the result.\n     */\n    function le(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint64 b)  and returns the result.\n     */\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint64 b)  and returns the result.\n     */\n    function min(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint64 b)  and returns the result.\n     */\n    function max(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, euint128 b)  and returns the result.\n     */\n    function add(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, euint128 b)  and returns the result.\n     */\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, euint128 b)  and returns the result.\n     */\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint128 b)  and returns the result.\n     */\n    function and(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint128 b)  and returns the result.\n     */\n    function or(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint128 b)  and returns the result.\n     */\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint128 b)  and returns the result.\n     */\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint128 b)  and returns the result.\n     */\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, euint128 b)  and returns the result.\n     */\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, euint128 b)  and returns the result.\n     */\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, euint128 b)  and returns the result.\n     */\n    function le(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, euint128 b)  and returns the result.\n     */\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, euint128 b)  and returns the result.\n     */\n    function min(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, euint128 b)  and returns the result.\n     */\n    function max(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, euint256 b)  and returns the result.\n     */\n    function and(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, euint256 b)  and returns the result.\n     */\n    function or(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, euint256 b)  and returns the result.\n     */\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, euint256 b)  and returns the result.\n     */\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, euint256 b)  and returns the result.\n     */\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint8 b)  and returns the result.\n     */\n    function add(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint8 b)  and returns the result.\n     */\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint8 b)  and returns the result.\n     */\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint8 b)  and returns the result.\n     */\n    function and(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint8 b)  and returns the result.\n     */\n    function or(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint8 b)  and returns the result.\n     */\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint8 b)  and returns the result.\n     */\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint8 b)  and returns the result.\n     */\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint8 b)  and returns the result.\n     */\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint8 b)  and returns the result.\n     */\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint8 b)  and returns the result.\n     */\n    function le(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint8 b)  and returns the result.\n     */\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint8 b)  and returns the result.\n     */\n    function min(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint8 b)  and returns the result.\n     */\n    function max(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint16 b)  and returns the result.\n     */\n    function add(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint16 b)  and returns the result.\n     */\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint16 b)  and returns the result.\n     */\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint16 b)  and returns the result.\n     */\n    function and(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint16 b)  and returns the result.\n     */\n    function or(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint16 b)  and returns the result.\n     */\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint16 b)  and returns the result.\n     */\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint16 b)  and returns the result.\n     */\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint16 b)  and returns the result.\n     */\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint16 b)  and returns the result.\n     */\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint16 b)  and returns the result.\n     */\n    function le(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint16 b)  and returns the result.\n     */\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint16 b)  and returns the result.\n     */\n    function min(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint16 b)  and returns the result.\n     */\n    function max(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint32 b)  and returns the result.\n     */\n    function add(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint32 b)  and returns the result.\n     */\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint32 b)  and returns the result.\n     */\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint32 b)  and returns the result.\n     */\n    function and(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint32 b)  and returns the result.\n     */\n    function or(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint32 b)  and returns the result.\n     */\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint32 b)  and returns the result.\n     */\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint32 b)  and returns the result.\n     */\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint32 b)  and returns the result.\n     */\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint32 b)  and returns the result.\n     */\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint32 b)  and returns the result.\n     */\n    function le(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint32 b)  and returns the result.\n     */\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint32 b)  and returns the result.\n     */\n    function min(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint32 b)  and returns the result.\n     */\n    function max(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint64 b)  and returns the result.\n     */\n    function add(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint64 b)  and returns the result.\n     */\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint64 b)  and returns the result.\n     */\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint64 b)  and returns the result.\n     */\n    function and(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint64 b)  and returns the result.\n     */\n    function or(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint64 b)  and returns the result.\n     */\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint64 b)  and returns the result.\n     */\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint64 b)  and returns the result.\n     */\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint64 b)  and returns the result.\n     */\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint64 b)  and returns the result.\n     */\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint64 b)  and returns the result.\n     */\n    function le(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint64 b)  and returns the result.\n     */\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint64 b)  and returns the result.\n     */\n    function min(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint64 b)  and returns the result.\n     */\n    function max(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, euint128 b)  and returns the result.\n     */\n    function add(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, euint128 b)  and returns the result.\n     */\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, euint128 b)  and returns the result.\n     */\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint128 b)  and returns the result.\n     */\n    function and(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint128 b)  and returns the result.\n     */\n    function or(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint128 b)  and returns the result.\n     */\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint128 b)  and returns the result.\n     */\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint128 b)  and returns the result.\n     */\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, euint128 b)  and returns the result.\n     */\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, euint128 b)  and returns the result.\n     */\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, euint128 b)  and returns the result.\n     */\n    function le(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, euint128 b)  and returns the result.\n     */\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, euint128 b)  and returns the result.\n     */\n    function min(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, euint128 b)  and returns the result.\n     */\n    function max(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, euint256 b)  and returns the result.\n     */\n    function and(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, euint256 b)  and returns the result.\n     */\n    function or(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, euint256 b)  and returns the result.\n     */\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, euint256 b)  and returns the result.\n     */\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, euint256 b)  and returns the result.\n     */\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint8 b)  and returns the result.\n     */\n    function add(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint8 b)  and returns the result.\n     */\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint8 b)  and returns the result.\n     */\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint8 b)  and returns the result.\n     */\n    function and(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint8 b)  and returns the result.\n     */\n    function or(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint8 b)  and returns the result.\n     */\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint8 b)  and returns the result.\n     */\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint8 b)  and returns the result.\n     */\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint8 b)  and returns the result.\n     */\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint8 b)  and returns the result.\n     */\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint8 b)  and returns the result.\n     */\n    function le(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint8 b)  and returns the result.\n     */\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint8 b)  and returns the result.\n     */\n    function min(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint8 b)  and returns the result.\n     */\n    function max(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint16 b)  and returns the result.\n     */\n    function add(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint16 b)  and returns the result.\n     */\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint16 b)  and returns the result.\n     */\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint16 b)  and returns the result.\n     */\n    function and(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint16 b)  and returns the result.\n     */\n    function or(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint16 b)  and returns the result.\n     */\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint16 b)  and returns the result.\n     */\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint16 b)  and returns the result.\n     */\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint16 b)  and returns the result.\n     */\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint16 b)  and returns the result.\n     */\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint16 b)  and returns the result.\n     */\n    function le(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint16 b)  and returns the result.\n     */\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint16 b)  and returns the result.\n     */\n    function min(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint16 b)  and returns the result.\n     */\n    function max(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint32 b)  and returns the result.\n     */\n    function add(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint32 b)  and returns the result.\n     */\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint32 b)  and returns the result.\n     */\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint32 b)  and returns the result.\n     */\n    function and(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint32 b)  and returns the result.\n     */\n    function or(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint32 b)  and returns the result.\n     */\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint32 b)  and returns the result.\n     */\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint32 b)  and returns the result.\n     */\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint32 b)  and returns the result.\n     */\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint32 b)  and returns the result.\n     */\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint32 b)  and returns the result.\n     */\n    function le(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint32 b)  and returns the result.\n     */\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint32 b)  and returns the result.\n     */\n    function min(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint32 b)  and returns the result.\n     */\n    function max(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint64 b)  and returns the result.\n     */\n    function add(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint64 b)  and returns the result.\n     */\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint64 b)  and returns the result.\n     */\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint64 b)  and returns the result.\n     */\n    function and(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint64 b)  and returns the result.\n     */\n    function or(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint64 b)  and returns the result.\n     */\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint64 b)  and returns the result.\n     */\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint64 b)  and returns the result.\n     */\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint64 b)  and returns the result.\n     */\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint64 b)  and returns the result.\n     */\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint64 b)  and returns the result.\n     */\n    function le(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint64 b)  and returns the result.\n     */\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint64 b)  and returns the result.\n     */\n    function min(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint64 b)  and returns the result.\n     */\n    function max(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, euint128 b)  and returns the result.\n     */\n    function add(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, euint128 b)  and returns the result.\n     */\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, euint128 b)  and returns the result.\n     */\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint128 b)  and returns the result.\n     */\n    function and(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint128 b)  and returns the result.\n     */\n    function or(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint128 b)  and returns the result.\n     */\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint128 b)  and returns the result.\n     */\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint128 b)  and returns the result.\n     */\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, euint128 b)  and returns the result.\n     */\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, euint128 b)  and returns the result.\n     */\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, euint128 b)  and returns the result.\n     */\n    function le(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, euint128 b)  and returns the result.\n     */\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, euint128 b)  and returns the result.\n     */\n    function min(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, euint128 b)  and returns the result.\n     */\n    function max(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, euint256 b)  and returns the result.\n     */\n    function and(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, euint256 b)  and returns the result.\n     */\n    function or(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, euint256 b)  and returns the result.\n     */\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, euint256 b)  and returns the result.\n     */\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, euint256 b)  and returns the result.\n     */\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(eaddress a, eaddress b) and returns the result.\n     */\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(eaddress a, eaddress b) and returns the result.\n     */\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint8 b)  and returns the result.\n     */\n    function and(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint8 b)  and returns the result.\n     */\n    function or(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint8 b)  and returns the result.\n     */\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint8 b)  and returns the result.\n     */\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint8 b)  and returns the result.\n     */\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint16 b)  and returns the result.\n     */\n    function and(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint16 b)  and returns the result.\n     */\n    function or(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint16 b)  and returns the result.\n     */\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint16 b)  and returns the result.\n     */\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint16 b)  and returns the result.\n     */\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint32 b)  and returns the result.\n     */\n    function and(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint32 b)  and returns the result.\n     */\n    function or(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint32 b)  and returns the result.\n     */\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint32 b)  and returns the result.\n     */\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint32 b)  and returns the result.\n     */\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint64 b)  and returns the result.\n     */\n    function and(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint64 b)  and returns the result.\n     */\n    function or(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint64 b)  and returns the result.\n     */\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint64 b)  and returns the result.\n     */\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint64 b)  and returns the result.\n     */\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint128 b)  and returns the result.\n     */\n    function and(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint128 b)  and returns the result.\n     */\n    function or(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint128 b)  and returns the result.\n     */\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint128 b)  and returns the result.\n     */\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint128 b)  and returns the result.\n     */\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, euint256 b)  and returns the result.\n     */\n    function and(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, euint256 b)  and returns the result.\n     */\n    function or(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, euint256 b)  and returns the result.\n     */\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, euint256 b)  and returns the result.\n     */\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, euint256 b)  and returns the result.\n     */\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates and(ebool a, bool b) and returns the result.\n     */\n    function and(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.and(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates and(bool a, ebool b) and returns the result.\n     */\n    function and(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.and(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates or(ebool a, bool b) and returns the result.\n     */\n    function or(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.or(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates or(bool a, ebool b) and returns the result.\n     */\n    function or(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.or(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(ebool a, bool b) and returns the result.\n     */\n    function xor(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(bool a, ebool b) and returns the result.\n     */\n    function xor(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(ebool a, bool b) and returns the result.\n     */\n    function eq(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(bool a, ebool b) and returns the result.\n     */\n    function eq(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(ebool a, bool b) and returns the result.\n     */\n    function ne(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(bool a, ebool b) and returns the result.\n     */\n    function ne(bool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint8 a, uint8 b) and returns the result.\n     */\n    function add(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint8 a, euint8 b) and returns the result.\n     */\n    function add(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint8 a, uint8 b) and returns the result.\n     */\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint8 a, euint8 b) and returns the result.\n     */\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint8 a, uint8 b) and returns the result.\n     */\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint8 a, euint8 b) and returns the result.\n     */\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint8 a, uint8 b) and returns the result.\n     */\n    function div(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint8 a, uint8 b) and returns the result.\n     */\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint8 a, uint8 b) and returns the result.\n     */\n    function and(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint8 a, euint8 b) and returns the result.\n     */\n    function and(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint8 a, uint8 b) and returns the result.\n     */\n    function or(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint8 a, euint8 b) and returns the result.\n     */\n    function or(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint8 a, uint8 b) and returns the result.\n     */\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint8 a, euint8 b) and returns the result.\n     */\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint8 a, uint8 b) and returns the result.\n     */\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint8 a, euint8 b) and returns the result.\n     */\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint8 a, uint8 b) and returns the result.\n     */\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint8 a, euint8 b) and returns the result.\n     */\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint8 a, uint8 b) and returns the result.\n     */\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint8 a, euint8 b) and returns the result.\n     */\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint8 a, uint8 b) and returns the result.\n     */\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint8 a, euint8 b) and returns the result.\n     */\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint8 a, uint8 b) and returns the result.\n     */\n    function le(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint8 a, euint8 b) and returns the result.\n     */\n    function le(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint8 a, uint8 b) and returns the result.\n     */\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint8 a, euint8 b) and returns the result.\n     */\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint8 a, uint8 b) and returns the result.\n     */\n    function min(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint8 a, euint8 b) and returns the result.\n     */\n    function min(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint8 a, uint8 b) and returns the result.\n     */\n    function max(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint8 a, euint8 b) and returns the result.\n     */\n    function max(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint16 a, uint16 b) and returns the result.\n     */\n    function add(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint16 a, euint16 b) and returns the result.\n     */\n    function add(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint16 a, uint16 b) and returns the result.\n     */\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint16 a, euint16 b) and returns the result.\n     */\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint16 a, uint16 b) and returns the result.\n     */\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint16 a, euint16 b) and returns the result.\n     */\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint16 a, uint16 b) and returns the result.\n     */\n    function div(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint16 a, uint16 b) and returns the result.\n     */\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint16 a, uint16 b) and returns the result.\n     */\n    function and(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint16 a, euint16 b) and returns the result.\n     */\n    function and(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint16 a, uint16 b) and returns the result.\n     */\n    function or(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint16 a, euint16 b) and returns the result.\n     */\n    function or(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint16 a, uint16 b) and returns the result.\n     */\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint16 a, euint16 b) and returns the result.\n     */\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint16 a, uint16 b) and returns the result.\n     */\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint16 a, euint16 b) and returns the result.\n     */\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint16 a, uint16 b) and returns the result.\n     */\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint16 a, euint16 b) and returns the result.\n     */\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint16 a, uint16 b) and returns the result.\n     */\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint16 a, euint16 b) and returns the result.\n     */\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint16 a, uint16 b) and returns the result.\n     */\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint16 a, euint16 b) and returns the result.\n     */\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint16 a, uint16 b) and returns the result.\n     */\n    function le(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint16 a, euint16 b) and returns the result.\n     */\n    function le(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint16 a, uint16 b) and returns the result.\n     */\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint16 a, euint16 b) and returns the result.\n     */\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint16 a, uint16 b) and returns the result.\n     */\n    function min(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint16 a, euint16 b) and returns the result.\n     */\n    function min(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint16 a, uint16 b) and returns the result.\n     */\n    function max(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint16 a, euint16 b) and returns the result.\n     */\n    function max(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint32 a, uint32 b) and returns the result.\n     */\n    function add(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint32 a, euint32 b) and returns the result.\n     */\n    function add(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint32 a, uint32 b) and returns the result.\n     */\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint32 a, euint32 b) and returns the result.\n     */\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint32 a, uint32 b) and returns the result.\n     */\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint32 a, euint32 b) and returns the result.\n     */\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint32 a, uint32 b) and returns the result.\n     */\n    function div(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint32 a, uint32 b) and returns the result.\n     */\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint32 a, uint32 b) and returns the result.\n     */\n    function and(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint32 a, euint32 b) and returns the result.\n     */\n    function and(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint32 a, uint32 b) and returns the result.\n     */\n    function or(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint32 a, euint32 b) and returns the result.\n     */\n    function or(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint32 a, uint32 b) and returns the result.\n     */\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint32 a, euint32 b) and returns the result.\n     */\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint32 a, uint32 b) and returns the result.\n     */\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint32 a, euint32 b) and returns the result.\n     */\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint32 a, uint32 b) and returns the result.\n     */\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint32 a, euint32 b) and returns the result.\n     */\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint32 a, uint32 b) and returns the result.\n     */\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint32 a, euint32 b) and returns the result.\n     */\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint32 a, uint32 b) and returns the result.\n     */\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint32 a, euint32 b) and returns the result.\n     */\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint32 a, uint32 b) and returns the result.\n     */\n    function le(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint32 a, euint32 b) and returns the result.\n     */\n    function le(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint32 a, uint32 b) and returns the result.\n     */\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint32 a, euint32 b) and returns the result.\n     */\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint32 a, uint32 b) and returns the result.\n     */\n    function min(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint32 a, euint32 b) and returns the result.\n     */\n    function min(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint32 a, uint32 b) and returns the result.\n     */\n    function max(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint32 a, euint32 b) and returns the result.\n     */\n    function max(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint64 a, uint64 b) and returns the result.\n     */\n    function add(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint64 a, euint64 b) and returns the result.\n     */\n    function add(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint64 a, uint64 b) and returns the result.\n     */\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint64 a, euint64 b) and returns the result.\n     */\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\n        euint64 aEnc = asEuint64(a);\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint64 a, uint64 b) and returns the result.\n     */\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint64 a, euint64 b) and returns the result.\n     */\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint64 a, uint64 b) and returns the result.\n     */\n    function div(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.div(euint64.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint64 a, uint64 b) and returns the result.\n     */\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint64 a, uint64 b) and returns the result.\n     */\n    function and(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint64 a, euint64 b) and returns the result.\n     */\n    function and(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint64 a, uint64 b) and returns the result.\n     */\n    function or(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint64 a, euint64 b) and returns the result.\n     */\n    function or(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint64 a, uint64 b) and returns the result.\n     */\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint64 a, euint64 b) and returns the result.\n     */\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint64 a, uint64 b) and returns the result.\n     */\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint64 a, euint64 b) and returns the result.\n     */\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint64 a, uint64 b) and returns the result.\n     */\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint64 a, euint64 b) and returns the result.\n     */\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint64 a, uint64 b) and returns the result.\n     */\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint64 a, euint64 b) and returns the result.\n     */\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint64 a, uint64 b) and returns the result.\n     */\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint64 a, euint64 b) and returns the result.\n     */\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint64 a, uint64 b) and returns the result.\n     */\n    function le(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint64 a, euint64 b) and returns the result.\n     */\n    function le(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint64 a, uint64 b) and returns the result.\n     */\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint64 a, euint64 b) and returns the result.\n     */\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint64 a, uint64 b) and returns the result.\n     */\n    function min(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint64 a, euint64 b) and returns the result.\n     */\n    function min(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint64 a, uint64 b) and returns the result.\n     */\n    function max(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint64 a, euint64 b) and returns the result.\n     */\n    function max(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates add(euint128 a, uint128 b) and returns the result.\n     */\n    function add(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates add(uint128 a, euint128 b) and returns the result.\n     */\n    function add(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(euint128 a, uint128 b) and returns the result.\n     */\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates sub(uint128 a, euint128 b) and returns the result.\n     */\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\n        euint128 aEnc = asEuint128(a);\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates mul(euint128 a, uint128 b) and returns the result.\n     */\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates mul(uint128 a, euint128 b) and returns the result.\n     */\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates div(euint128 a, uint128 b) and returns the result.\n     */\n    function div(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.div(euint128.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates rem(euint128 a, uint128 b) and returns the result.\n     */\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), bytes32(uint256(b))));\n    }\n\n    /**\n     * @dev Evaluates and(euint128 a, uint128 b) and returns the result.\n     */\n    function and(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint128 a, euint128 b) and returns the result.\n     */\n    function and(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint128 a, uint128 b) and returns the result.\n     */\n    function or(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint128 a, euint128 b) and returns the result.\n     */\n    function or(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint128 a, uint128 b) and returns the result.\n     */\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint128 a, euint128 b) and returns the result.\n     */\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint128 a, uint128 b) and returns the result.\n     */\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint128 a, euint128 b) and returns the result.\n     */\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint128 a, uint128 b) and returns the result.\n     */\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint128 a, euint128 b) and returns the result.\n     */\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(euint128 a, uint128 b) and returns the result.\n     */\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ge(uint128 a, euint128 b) and returns the result.\n     */\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(euint128 a, uint128 b) and returns the result.\n     */\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates gt(uint128 a, euint128 b) and returns the result.\n     */\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates le(euint128 a, uint128 b) and returns the result.\n     */\n    function le(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates le(uint128 a, euint128 b) and returns the result.\n     */\n    function le(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(euint128 a, uint128 b) and returns the result.\n     */\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates lt(uint128 a, euint128 b) and returns the result.\n     */\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates min(euint128 a, uint128 b) and returns the result.\n     */\n    function min(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates min(uint128 a, euint128 b) and returns the result.\n     */\n    function min(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates max(euint128 a, uint128 b) and returns the result.\n     */\n    function max(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates max(uint128 a, euint128 b) and returns the result.\n     */\n    function max(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(eaddress a, address b) and returns the result.\n     */\n    function eq(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\n    }\n\n    /**\n     * @dev Evaluates eq(address a, eaddress b) and returns the result.\n     */\n    function eq(address a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\n    }\n\n    /**\n     * @dev Evaluates ne(eaddress a, address b) and returns the result.\n     */\n    function ne(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\n    }\n\n    /**\n     * @dev Evaluates ne(address a, eaddress b) and returns the result.\n     */\n    function ne(address a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\n    }\n\n    /**\n     * @dev Evaluates and(euint256 a, uint256 b) and returns the result.\n     */\n    function and(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates and(uint256 a, euint256 b) and returns the result.\n     */\n    function and(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates or(euint256 a, uint256 b) and returns the result.\n     */\n    function or(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates or(uint256 a, euint256 b) and returns the result.\n     */\n    function or(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(euint256 a, uint256 b) and returns the result.\n     */\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates xor(uint256 a, euint256 b) and returns the result.\n     */\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(euint256 a, uint256 b) and returns the result.\n     */\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates eq(uint256 a, euint256 b) and returns the result.\n     */\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(euint256 a, uint256 b) and returns the result.\n     */\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates ne(uint256 a, euint256 b) and returns the result.\n     */\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), bytes32(uint256(a)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint8 a, euint8 b) and returns the result.\n     */\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint8 a, uint8) and returns the result.\n     */\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint8 a, euint8 b) and returns the result.\n     */\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint8 a, uint8) and returns the result.\n     */\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint8 a, euint8 b) and returns the result.\n     */\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint8 a, uint8) and returns the result.\n     */\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint8 a, euint8 b) and returns the result.\n     */\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint8 a, uint8) and returns the result.\n     */\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint16 a, euint8 b) and returns the result.\n     */\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint16 a, uint8) and returns the result.\n     */\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint16 a, euint8 b) and returns the result.\n     */\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint16 a, uint8) and returns the result.\n     */\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint16 a, euint8 b) and returns the result.\n     */\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint16 a, uint8) and returns the result.\n     */\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint16 a, euint8 b) and returns the result.\n     */\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint16 a, uint8) and returns the result.\n     */\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint32 a, euint8 b) and returns the result.\n     */\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint32 a, uint8) and returns the result.\n     */\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint32 a, euint8 b) and returns the result.\n     */\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint32 a, uint8) and returns the result.\n     */\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint32 a, euint8 b) and returns the result.\n     */\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint32 a, uint8) and returns the result.\n     */\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint32 a, euint8 b) and returns the result.\n     */\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint32 a, uint8) and returns the result.\n     */\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint64 a, euint8 b) and returns the result.\n     */\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint64 a, uint8) and returns the result.\n     */\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint64 a, euint8 b) and returns the result.\n     */\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint64 a, uint8) and returns the result.\n     */\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint64 a, euint8 b) and returns the result.\n     */\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint64 a, uint8) and returns the result.\n     */\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint64 a, euint8 b) and returns the result.\n     */\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint64 a, uint8) and returns the result.\n     */\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint128 a, euint8 b) and returns the result.\n     */\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint128 a, uint8) and returns the result.\n     */\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint128 a, euint8 b) and returns the result.\n     */\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint128 a, uint8) and returns the result.\n     */\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint128 a, euint8 b) and returns the result.\n     */\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint128 a, uint8) and returns the result.\n     */\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint128 a, euint8 b) and returns the result.\n     */\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint128 a, uint8) and returns the result.\n     */\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shl(euint256 a, euint8 b) and returns the result.\n     */\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shl(euint256 a, uint8) and returns the result.\n     */\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates shr(euint256 a, euint8 b) and returns the result.\n     */\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates shr(euint256 a, uint8) and returns the result.\n     */\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint256 a, euint8 b) and returns the result.\n     */\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotl(euint256 a, uint8) and returns the result.\n     */\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint256 a, euint8 b) and returns the result.\n     */\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    /**\n     * @dev Evaluates rotr(euint256 a, uint8) and returns the result.\n     */\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), bytes32(uint256(b)), true));\n    }\n\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\n    }\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\n    }\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint8'.\n     */\n    function asEuint8(euint16 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint8'.\n     */\n    function asEuint8(euint32 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint8'.\n     */\n    function asEuint8(euint64 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint8'.\n     */\n    function asEuint8(euint128 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint8'.\n     */\n    function asEuint8(euint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint8));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint8'.\n     */\n    function asEuint8(ebool b) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint8));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'ebool'.\n     */\n    function asEbool(euint8 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint16'.\n     */\n    function asEuint16(euint8 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint16'.\n     */\n    function asEuint16(euint32 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint16'.\n     */\n    function asEuint16(euint64 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint16'.\n     */\n    function asEuint16(euint128 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint16'.\n     */\n    function asEuint16(euint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint16));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint16'.\n     */\n    function asEuint16(ebool b) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint16));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'ebool'.\n     */\n    function asEbool(euint16 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint32'.\n     */\n    function asEuint32(euint8 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint32'.\n     */\n    function asEuint32(euint16 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint32'.\n     */\n    function asEuint32(euint64 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint32'.\n     */\n    function asEuint32(euint128 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint32'.\n     */\n    function asEuint32(euint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint32));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint32'.\n     */\n    function asEuint32(ebool b) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint32));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'ebool'.\n     */\n    function asEbool(euint32 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint64'.\n     */\n    function asEuint64(euint8 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint64'.\n     */\n    function asEuint64(euint16 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint64'.\n     */\n    function asEuint64(euint32 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint64'.\n     */\n    function asEuint64(euint128 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint64'.\n     */\n    function asEuint64(euint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint64));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint64'.\n     */\n    function asEuint64(ebool b) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint64));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'ebool'.\n     */\n    function asEbool(euint64 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint128'.\n     */\n    function asEuint128(euint8 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint128'.\n     */\n    function asEuint128(euint16 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint128'.\n     */\n    function asEuint128(euint32 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint128'.\n     */\n    function asEuint128(euint64 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'euint128'.\n     */\n    function asEuint128(euint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint128));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint128'.\n     */\n    function asEuint128(ebool b) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint128));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'ebool'.\n     */\n    function asEbool(euint128 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint8' to 'euint256'.\n     */\n    function asEuint256(euint8 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint16' to 'euint256'.\n     */\n    function asEuint256(euint16 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint32' to 'euint256'.\n     */\n    function asEuint256(euint32 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint64' to 'euint256'.\n     */\n    function asEuint256(euint64 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint128' to 'euint256'.\n     */\n    function asEuint256(euint128 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint256));\n    }\n\n    /**\n    /** \n     * @dev Converts an 'ebool' to an 'euint256'.\n     */\n    function asEuint256(ebool b) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint256));\n    }\n\n    /**\n     * @dev Casts an encrypted integer from 'euint256' to 'ebool'.\n     */\n    function asEbool(euint256 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    /**\n     * @dev Evaluates not(ebool value) and returns the result.\n     */\n    function not(ebool value) internal returns (ebool) {\n        return ebool.wrap(Impl.not(ebool.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint8 value) and returns the result.\n     */\n    function neg(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint8 value) and returns the result.\n     */\n    function not(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint16 value) and returns the result.\n     */\n    function neg(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint16 value) and returns the result.\n     */\n    function not(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint32 value) and returns the result.\n     */\n    function neg(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint32 value) and returns the result.\n     */\n    function not(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint64 value) and returns the result.\n     */\n    function neg(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint64 value) and returns the result.\n     */\n    function not(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint128 value) and returns the result.\n     */\n    function neg(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint128 value) and returns the result.\n     */\n    function not(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates neg(euint256 value) and returns the result.\n     */\n    function neg(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\n    }\n\n    /**\n     * @dev Evaluates not(euint256 value) and returns the result.\n     */\n    function not(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted ebool integer.\n     */\n    function fromExternal(externalEbool inputHandle, bytes memory inputProof) internal returns (ebool) {\n        return ebool.wrap(Impl.verify(externalEbool.unwrap(inputHandle), inputProof, FheType.Bool));\n    }\n\n    /**\n     * @dev Converts a plaintext boolean to an encrypted boolean.\n     */\n    function asEbool(bool value) internal returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value ? 1 : 0, FheType.Bool));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\n     */\n    function fromExternal(externalEuint8 inputHandle, bytes memory inputProof) internal returns (euint8) {\n        return euint8.wrap(Impl.verify(externalEuint8.unwrap(inputHandle), inputProof, FheType.Uint8));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint8 integer.\n     */\n    function asEuint8(uint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint8));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\n     */\n    function fromExternal(externalEuint16 inputHandle, bytes memory inputProof) internal returns (euint16) {\n        return euint16.wrap(Impl.verify(externalEuint16.unwrap(inputHandle), inputProof, FheType.Uint16));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint16 integer.\n     */\n    function asEuint16(uint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint16));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\n     */\n    function fromExternal(externalEuint32 inputHandle, bytes memory inputProof) internal returns (euint32) {\n        return euint32.wrap(Impl.verify(externalEuint32.unwrap(inputHandle), inputProof, FheType.Uint32));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint32 integer.\n     */\n    function asEuint32(uint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint32));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\n     */\n    function fromExternal(externalEuint64 inputHandle, bytes memory inputProof) internal returns (euint64) {\n        return euint64.wrap(Impl.verify(externalEuint64.unwrap(inputHandle), inputProof, FheType.Uint64));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint64 integer.\n     */\n    function asEuint64(uint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint64));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\n     */\n    function fromExternal(externalEuint128 inputHandle, bytes memory inputProof) internal returns (euint128) {\n        return euint128.wrap(Impl.verify(externalEuint128.unwrap(inputHandle), inputProof, FheType.Uint128));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint128 integer.\n     */\n    function asEuint128(uint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint128));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted eaddress integer.\n     */\n    function fromExternal(externalEaddress inputHandle, bytes memory inputProof) internal returns (eaddress) {\n        return eaddress.wrap(Impl.verify(externalEaddress.unwrap(inputHandle), inputProof, FheType.Uint160));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted eaddress integer.\n     */\n    function asEaddress(address value) internal returns (eaddress) {\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), FheType.Uint160));\n    }\n\n    /**\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\n     */\n    function fromExternal(externalEuint256 inputHandle, bytes memory inputProof) internal returns (euint256) {\n        return euint256.wrap(Impl.verify(externalEuint256.unwrap(inputHandle), inputProof, FheType.Uint256));\n    }\n\n    /**\n     * @dev Convert a plaintext value to an encrypted euint256 integer.\n     */\n    function asEuint256(uint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint256));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEbool() internal returns (ebool) {\n        return ebool.wrap(Impl.rand(FheType.Bool));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint8() internal returns (euint8) {\n        return euint8.wrap(Impl.rand(FheType.Uint8));\n    }\n\n    /**\n     * @dev Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\n        return euint8.wrap(Impl.randBounded(upperBound, FheType.Uint8));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint16() internal returns (euint16) {\n        return euint16.wrap(Impl.rand(FheType.Uint16));\n    }\n\n    /**\n     * @dev Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\n        return euint16.wrap(Impl.randBounded(upperBound, FheType.Uint16));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint32() internal returns (euint32) {\n        return euint32.wrap(Impl.rand(FheType.Uint32));\n    }\n\n    /**\n     * @dev Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\n        return euint32.wrap(Impl.randBounded(upperBound, FheType.Uint32));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint64() internal returns (euint64) {\n        return euint64.wrap(Impl.rand(FheType.Uint64));\n    }\n\n    /**\n     * @dev Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\n        return euint64.wrap(Impl.randBounded(upperBound, FheType.Uint64));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint128() internal returns (euint128) {\n        return euint128.wrap(Impl.rand(FheType.Uint128));\n    }\n\n    /**\n     * @dev Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\n        return euint128.wrap(Impl.randBounded(upperBound, FheType.Uint128));\n    }\n\n    /**\n     * @dev Generates a random encrypted value.\n     */\n    function randEuint256() internal returns (euint256) {\n        return euint256.wrap(Impl.rand(FheType.Uint256));\n    }\n\n    /**\n     * @dev Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\n     *      The upperBound must be a power of 2.\n     */\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\n        return euint256.wrap(Impl.randBounded(upperBound, FheType.Uint256));\n    }\n\n    /**\n     * @dev This function cleans the transient storage for the ACL (accounts) and the InputVerifier\n     *      (input proofs).\n     *      This could be useful for integration with Account Abstraction when bundling several\n     *      UserOps calling the FHEVMExecutor.\n     */\n    function cleanTransientStorage() internal {\n        Impl.cleanTransientStorageACL();\n        Impl.cleanTransientStorageInputVerifier();\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(ebool value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(ebool value) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(ebool value, address account) internal returns (ebool) {\n        Impl.allow(ebool.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(ebool value) internal returns (ebool) {\n        Impl.allow(ebool.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(ebool value, address account) internal returns (ebool) {\n        Impl.allowTransient(ebool.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(ebool value) internal returns (ebool) {\n        Impl.makePubliclyDecryptable(ebool.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(ebool value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(ebool.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint8 value, address account) internal returns (euint8) {\n        Impl.allow(euint8.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint8 value) internal returns (euint8) {\n        Impl.allow(euint8.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint8 value, address account) internal returns (euint8) {\n        Impl.allowTransient(euint8.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint8 value) internal returns (euint8) {\n        Impl.makePubliclyDecryptable(euint8.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint8 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint8.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint16 value, address account) internal returns (euint16) {\n        Impl.allow(euint16.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint16 value) internal returns (euint16) {\n        Impl.allow(euint16.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint16 value, address account) internal returns (euint16) {\n        Impl.allowTransient(euint16.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint16 value) internal returns (euint16) {\n        Impl.makePubliclyDecryptable(euint16.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint16 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint16.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint32 value, address account) internal returns (euint32) {\n        Impl.allow(euint32.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint32 value) internal returns (euint32) {\n        Impl.allow(euint32.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint32 value, address account) internal returns (euint32) {\n        Impl.allowTransient(euint32.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint32 value) internal returns (euint32) {\n        Impl.makePubliclyDecryptable(euint32.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint32 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint32.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint64 value, address account) internal returns (euint64) {\n        Impl.allow(euint64.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint64 value) internal returns (euint64) {\n        Impl.allow(euint64.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint64 value, address account) internal returns (euint64) {\n        Impl.allowTransient(euint64.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint64 value) internal returns (euint64) {\n        Impl.makePubliclyDecryptable(euint64.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint64 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint64.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint128 value, address account) internal returns (euint128) {\n        Impl.allow(euint128.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint128 value) internal returns (euint128) {\n        Impl.allow(euint128.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint128 value, address account) internal returns (euint128) {\n        Impl.allowTransient(euint128.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint128 value) internal returns (euint128) {\n        Impl.makePubliclyDecryptable(euint128.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint128 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint128.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(eaddress value, address account) internal returns (eaddress) {\n        Impl.allow(eaddress.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(eaddress value) internal returns (eaddress) {\n        Impl.allow(eaddress.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(eaddress value, address account) internal returns (eaddress) {\n        Impl.allowTransient(eaddress.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(eaddress value) internal returns (eaddress) {\n        Impl.makePubliclyDecryptable(eaddress.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(eaddress value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(eaddress.unwrap(value));\n    }\n\n    /**\n     * @dev Returns whether the account is allowed to use the value.\n     */\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), account);\n    }\n\n    /**\n     * @dev Returns whether the sender is allowed to use the value.\n     */\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\n    }\n\n    /**\n     * @dev Allows the use of value for the address account.\n     */\n    function allow(euint256 value, address account) internal returns (euint256) {\n        Impl.allow(euint256.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value for this address (address(this)).\n     */\n    function allowThis(euint256 value) internal returns (euint256) {\n        Impl.allow(euint256.unwrap(value), address(this));\n        return value;\n    }\n\n    /**\n     * @dev Allows the use of value by address account for this transaction.\n     */\n    function allowTransient(euint256 value, address account) internal returns (euint256) {\n        Impl.allowTransient(euint256.unwrap(value), account);\n        return value;\n    }\n\n    /**\n     * @dev Makes the value publicly decryptable.\n     */\n    function makePubliclyDecryptable(euint256 value) internal returns (euint256) {\n        Impl.makePubliclyDecryptable(euint256.unwrap(value));\n        return value;\n    }\n\n    /**\n     * @dev Returns whether the the value is publicly decryptable.\n     */\n    function isPubliclyDecryptable(euint256 value) internal view returns (bool) {\n        return Impl.isPubliclyDecryptable(euint256.unwrap(value));\n    }\n\n    /**\n     * @dev Recovers the stored array of handles corresponding to requestID.\n     */\n    function loadRequestedHandles(uint256 requestID) internal view returns (bytes32[] memory) {\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\n        if ($.requestedHandles[requestID].length == 0) {\n            revert NoHandleFoundForRequestID();\n        }\n        return $.requestedHandles[requestID];\n    }\n\n    /**\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles.\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\n     */\n    function requestDecryption(\n        bytes32[] memory ctsHandles,\n        bytes4 callbackSelector\n    ) internal returns (uint256 requestID) {\n        requestID = requestDecryption(ctsHandles, callbackSelector, 0);\n    }\n\n    /**\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles, with a custom msgValue.\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\n     */\n    function requestDecryption(\n        bytes32[] memory ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue\n    ) internal returns (uint256 requestID) {\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\n        requestID = $.counterRequest;\n        CoprocessorConfig storage $$ = Impl.getCoprocessorConfig();\n        IACL($$.ACLAddress).allowForDecryption(ctsHandles);\n        IDecryptionOracle($$.DecryptionOracleAddress).requestDecryption{value: msgValue}(\n            requestID,\n            ctsHandles,\n            callbackSelector\n        );\n        saveRequestedHandles(requestID, ctsHandles);\n        $.counterRequest++;\n    }\n\n    /**\n     * @dev     MUST be called inside the callback function the dApp contract to verify the signatures,\n     * @dev     otherwise fake decryption results could be submitted.\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\n     */\n    function checkSignatures(uint256 requestID, bytes memory cleartexts, bytes memory decryptionProof) internal {\n        bytes32[] memory handlesList = loadRequestedHandles(requestID);\n        bool isVerified = verifySignatures(handlesList, cleartexts, decryptionProof);\n        if (!isVerified) {\n            revert InvalidKMSSignatures();\n        }\n        emit DecryptionFulfilled(requestID);\n    }\n\n    /**\n     * @dev Private low-level function used to link in storage an array of handles to its associated requestID.\n     */\n    function saveRequestedHandles(uint256 requestID, bytes32[] memory handlesList) private {\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\n        if ($.requestedHandles[requestID].length != 0) {\n            revert HandlesAlreadySavedForRequestID();\n        }\n        $.requestedHandles[requestID] = handlesList;\n    }\n\n    /**\n     * @dev Private low-level function used to extract the decryptedResult bytes array and verify the KMS signatures.\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\n     * @dev The callback function has the following signature:\n     * - requestID (static uint256)\n     * - cleartexts (dynamic bytes)\n     * - decryptionProof (dynamic bytes)\n     *\n     * This means that the calldata is encoded in the following way:\n     * - 4 bytes: selector\n     * - 32 bytes: requestID\n     * - 32 bytes: offset of the cleartexts\n     * - 32 bytes: offset of the decryptionProof\n     * - 32 bytes: length of the cleartexts (total number of bytes)\n     * - n*32 bytes: the \"n\" cleartext values, with \"n\" the number of handles\n     * - 32 bytes: length of the decryptionProof (total number of bytes)\n     * - ... the data of the decryptionProof (signatures, extra data)\n     */\n    function verifySignatures(\n        bytes32[] memory handlesList,\n        bytes memory cleartexts,\n        bytes memory decryptionProof\n    ) private returns (bool) {\n        // Compute the signature offset\n        // This offset is computed by considering the format encoded by the KMS when creating the\n        // \"decryptedResult\" bytes array (see comment below), which is the following:\n        // - requestID: 32 bytes\n        // - all \"n\" decrypted values (which is \"cleartexts\" itself): n*32 bytes (\"cleartexts.length\" bytes)\n        // - offset of the signatures: 32 bytes\n        // - the rest of signature values (lengths, offsets, values)\n        // This means the expected offset to concatenate to the \"decryptedResult\" bytes array has\n        // the following value: 32 + n*32 + 32\n        // See https://docs.soliditylang.org/en/latest/abi-spec.html#use-of-dynamic-types for more details.\n        // The signature offset will most likely be removed in the future,\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\n        uint256 signaturesOffset = 32 + cleartexts.length + 32;\n\n        // Built the \"decryptedResult\" bytes array\n        // Currently, the \"decryptedResult\" is encoded (by the KMS) in the following format:\n        // - n*32 bytes: the \"n\" decrypted values, \"cleartexts\" itself\n        // - 32 bytes: offset of the signatures, as explained above\n        // This is equivalent to concatenating the cleartexts and the signatures offset, which can\n        // be done using abi.encoded in a gas efficient way.\n        // The signature offset will most likely be removed in the future,\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\n        // Here we can use \"encodePacked\" instead of \"abi.encode\" to save gas, as the cleartexts\n        // and the signaturesOffset are already 32 bytes aligned (ie, no padding needed).\n        bytes memory decryptedResult = abi.encodePacked(cleartexts, signaturesOffset);\n\n        CoprocessorConfig storage $ = Impl.getCoprocessorConfig();\n        return\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\n                handlesList,\n                decryptedResult,\n                decryptionProof\n            );\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(ebool value) internal pure returns (bytes32 ct) {\n        ct = ebool.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint8 value) internal pure returns (bytes32 ct) {\n        ct = euint8.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint16 value) internal pure returns (bytes32 ct) {\n        ct = euint16.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint32 value) internal pure returns (bytes32 ct) {\n        ct = euint32.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint64 value) internal pure returns (bytes32 ct) {\n        ct = euint64.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint128 value) internal pure returns (bytes32 ct) {\n        ct = euint128.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(eaddress value) internal pure returns (bytes32 ct) {\n        ct = eaddress.unwrap(value);\n    }\n\n    /**\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\n     */\n    function toBytes32(euint256 value) internal pure returns (bytes32 ct) {\n        ct = euint256.unwrap(value);\n    }\n}\n"
    },
    "@fhevm/solidity/lib/FheType.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nenum FheType {\n    Bool,\n    Uint4,\n    Uint8,\n    Uint16,\n    Uint32,\n    Uint64,\n    Uint128,\n    Uint160,\n    Uint256,\n    Uint512,\n    Uint1024,\n    Uint2048,\n    Uint2,\n    Uint6,\n    Uint10,\n    Uint12,\n    Uint14,\n    Int2,\n    Int4,\n    Int6,\n    Int8,\n    Int10,\n    Int12,\n    Int14,\n    Int16,\n    Int32,\n    Int64,\n    Int128,\n    Int160,\n    Int256,\n    AsciiString,\n    Int512,\n    Int1024,\n    Int2048,\n    Uint24,\n    Uint40,\n    Uint48,\n    Uint56,\n    Uint72,\n    Uint80,\n    Uint88,\n    Uint96,\n    Uint104,\n    Uint112,\n    Uint120,\n    Uint136,\n    Uint144,\n    Uint152,\n    Uint168,\n    Uint176,\n    Uint184,\n    Uint192,\n    Uint200,\n    Uint208,\n    Uint216,\n    Uint224,\n    Uint232,\n    Uint240,\n    Uint248,\n    Int24,\n    Int40,\n    Int48,\n    Int56,\n    Int72,\n    Int80,\n    Int88,\n    Int96,\n    Int104,\n    Int112,\n    Int120,\n    Int136,\n    Int144,\n    Int152,\n    Int168,\n    Int176,\n    Int184,\n    Int192,\n    Int200,\n    Int208,\n    Int216,\n    Int224,\n    Int232,\n    Int240,\n    Int248\n}\n"
    },
    "@fhevm/solidity/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {FheType} from \"./FheType.sol\";\n\n/**\n * @title   CoprocessorConfig\n * @notice  This struct contains all addresses of core contracts, which are needed in a typical dApp.\n */\nstruct CoprocessorConfig {\n    address ACLAddress;\n    address CoprocessorAddress;\n    address DecryptionOracleAddress;\n    address KMSVerifierAddress;\n}\n\n/**\n * @title   DecryptionRequests\n * @notice  This struct contains the internal counter for requestIDs generated by the dapp,\n *          and the mapping from internal requestIDs to list of handles requested for decryption.\n */\nstruct DecryptionRequests {\n    uint256 counterRequest;\n    mapping(uint256 => bytes32[]) requestedHandles;\n}\n\n/**\n * @title   IFHEVMExecutor\n * @notice  This interface contains all functions to conduct FHE operations.\n */\ninterface IFHEVMExecutor {\n    /**\n     * @notice              Computes fheAdd operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheSub operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheMul operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheDiv operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheRem operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheBitAnd operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheBitOr operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheBitXor operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheShl operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheShr operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheRotl operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheRotr operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheEq operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheNe operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheGe operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheGt operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheLe operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheLt operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheMin operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheMax operation.\n     * @param lhs           LHS.\n     * @param rhs           RHS.\n     * @param scalarByte    Scalar byte.\n     * @return result       Result.\n     */\n    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheNeg operation.\n     * @param ct            Ct\n     * @return result       Result.\n     */\n    function fheNeg(bytes32 ct) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes fheNot operation.\n     * @param ct            Ct\n     * @return result       Result.\n     */\n    function fheNot(bytes32 ct) external returns (bytes32 result);\n    /**\n     * @notice                Verifies the ciphertext.\n     * @param inputHandle     Input handle.\n     * @param callerAddress   Address of the caller.\n     * @param inputProof      Input proof.\n     * @param inputType       Input type.\n     * @return result         Result.\n     */\n    function verifyCiphertext(\n        bytes32 inputHandle,\n        address callerAddress,\n        bytes memory inputProof,\n        FheType inputType\n    ) external returns (bytes32 result);\n\n    /**\n     * @notice          Performs the casting to a target type.\n     * @param ct        Value to cast.\n     * @param toType    Target type.\n     * @return result   Result value of the target type.\n     */\n    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);\n\n    /**\n     * @notice          Does trivial encryption.\n     * @param ct        Value to encrypt.\n     * @param toType    Target type.\n     * @return result   Result value of the target type.\n     */\n    function trivialEncrypt(uint256 ct, FheType toType) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes FHEIfThenElse operation.\n     * @param control       Control value.\n     * @param ifTrue        If true.\n     * @param ifFalse       If false.\n     * @return result       Result.\n     */\n    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes FHERand operation.\n     * @param randType      Type for the random result.\n     * @return result       Result.\n     */\n    function fheRand(FheType randType) external returns (bytes32 result);\n\n    /**\n     * @notice              Computes FHERandBounded operation.\n     * @param upperBound    Upper bound value.\n     * @param randType      Type for the random result.\n     * @return result       Result.\n     */\n    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);\n\n    /**\n     * @notice                      Returns the address of the InputVerifier contract used by the coprocessor.\n     * @return inputVerifierAddress Address of the InputVerifier.\n     */\n    function getInputVerifierAddress() external view returns (address);\n}\n\n/**\n * @title   IACL.\n * @notice  This interface contains all functions that are used to conduct operations\n *          with the ACL contract.\n */\ninterface IACL {\n    /**\n     * @notice              Allows the use of handle by address account for this transaction.\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\n     *                      If not, allowTransient() reverts.\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\n     * @param ciphertext    Ciphertext.\n     * @param account       Address of the account.\n     */\n    function allowTransient(bytes32 ciphertext, address account) external;\n\n    /**\n     * @notice              Allows the use of handle for the address account.\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     */\n    function allow(bytes32 handle, address account) external;\n\n    /**\n     * @dev This function removes the transient allowances, which could be useful for integration with\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorage() external;\n\n    /**\n     * @notice              Returns whether the account is allowed to use the handle, either due to\n     *                      allowTransient() or allow().\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     * @return isAllowed    Whether the account can access the handle.\n     */\n    function isAllowed(bytes32 handle, address account) external view returns (bool);\n\n    /**\n     * @notice              Allows a list of handles to be decrypted.\n     * @param handlesList   List of handles.\n     */\n    function allowForDecryption(bytes32[] memory handlesList) external;\n\n    /**\n     * @notice                  Returns wether a handle is allowed to be publicly decrypted.\n     * @param handle            Handle.\n     * @return isDecryptable    Whether the handle can be publicly decrypted.\n     */\n    function isAllowedForDecryption(bytes32 handle) external view returns (bool);\n}\n\n/**\n * @title IInputVerifier\n * @notice This interface contains the only function required from InputVerifier.\n */\ninterface IInputVerifier {\n    /**\n     * @dev This function removes the transient allowances, which could be useful for integration with\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorage() external;\n}\n\n/**\n * @title   Impl\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\n */\nlibrary Impl {\n    /// keccak256(abi.encode(uint256(keccak256(\"confidential.storage.config\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant CoprocessorConfigLocation =\n        0x9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700;\n\n    /// keccak256(abi.encode(uint256(keccak256(\"confidential.storage.decryptionRequests\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 private constant DecryptionRequestsStorageLocation =\n        0x878245876662ba28a480c5ea71726db859fb50222b0a3d7cbbc21cfa336faf00;\n\n    /**\n     * @dev Returns the Coprocessor config.\n     */\n    function getCoprocessorConfig() internal pure returns (CoprocessorConfig storage $) {\n        assembly {\n            $.slot := CoprocessorConfigLocation\n        }\n    }\n\n    /**\n     * @dev Returns the DecryptionRequests storage struct.\n     */\n    function getDecryptionRequests() internal pure returns (DecryptionRequests storage $) {\n        assembly {\n            $.slot := DecryptionRequestsStorageLocation\n        }\n    }\n\n    /**\n     * @notice                  Sets the coprocessor addresses.\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\n     */\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        $.ACLAddress = coprocessorConfig.ACLAddress;\n        $.CoprocessorAddress = coprocessorConfig.CoprocessorAddress;\n        $.DecryptionOracleAddress = coprocessorConfig.DecryptionOracleAddress;\n        $.KMSVerifierAddress = coprocessorConfig.KMSVerifierAddress;\n    }\n\n    function add(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\n        bytes1 scalarByte = 0x01;\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function rem(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\n        bytes1 scalarByte = 0x01;\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRem(lhs, rhs, scalarByte);\n    }\n\n    function and(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function rotl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotl(lhs, rhs, scalarByte);\n    }\n\n    function rotr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotr(lhs, rhs, scalarByte);\n    }\n\n    function eq(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(bytes32 ct) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNeg(ct);\n    }\n\n    function not(bytes32 ct) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNot(ct);\n    }\n\n    /**\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\n     */\n    function select(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheIfThenElse(control, ifTrue, ifFalse);\n    }\n\n    /**\n     * @notice              Verifies the ciphertext (FHEVMExecutor) and allows transient (ACL).\n     * @param inputHandle   Input handle.\n     * @param inputProof    Input proof.\n     * @param toType        Input type.\n     * @return result       Result.\n     */\n    function verify(bytes32 inputHandle, bytes memory inputProof, FheType toType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).verifyCiphertext(inputHandle, msg.sender, inputProof, toType);\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\n    }\n\n    /**\n     * @notice            Performs the casting to a target type.\n     * @param ciphertext  Ciphertext to cast.\n     * @param toType      Target type.\n     * @return result     Result value of the target type.\n     */\n    function cast(bytes32 ciphertext, FheType toType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).cast(ciphertext, toType);\n    }\n\n    /**\n     * @notice          Does trivial encryption.\n     * @param value     Value to encrypt.\n     * @param toType    Target type.\n     * @return result   Result value of the target type.\n     */\n    function trivialEncrypt(uint256 value, FheType toType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).trivialEncrypt(value, toType);\n    }\n\n    function rand(FheType randType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRand(randType);\n    }\n\n    function randBounded(uint256 upperBound, FheType randType) internal returns (bytes32 result) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRandBounded(upperBound, randType);\n    }\n\n    /**\n     * @notice              Allows the use of handle by address account for this transaction.\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\n     *                      If not, allowTransient() reverts.\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     */\n    function allowTransient(bytes32 handle, address account) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        IACL($.ACLAddress).allowTransient(handle, account);\n    }\n\n    /**\n     * @notice              Allows the use of handle for the address account.\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     */\n    function allow(bytes32 handle, address account) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        IACL($.ACLAddress).allow(handle, account);\n    }\n\n    /**\n     * @notice              Allows the handle to be publicly decryptable.\n     * @dev                 The caller must be allowed to use handle for makePubliclyDecryptable() to succeed.\n     *                      If not, makePubliclyDecryptable() reverts.\n     * @param handle        Handle.\n     */\n    function makePubliclyDecryptable(bytes32 handle) internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        bytes32[] memory handleArray = new bytes32[](1);\n        handleArray[0] = handle;\n        IACL($.ACLAddress).allowForDecryption(handleArray);\n    }\n\n    /**\n     * @dev This function removes the transient allowances in the ACL, which could be useful for integration\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorageACL() internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        IACL($.ACLAddress).cleanTransientStorage();\n    }\n\n    /**\n     * @dev This function removes the transient proofs in the InputVerifier, which could be useful for integration\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\n     */\n    function cleanTransientStorageInputVerifier() internal {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        address inputVerifierAddress = IFHEVMExecutor($.CoprocessorAddress).getInputVerifierAddress();\n        IInputVerifier(inputVerifierAddress).cleanTransientStorage();\n    }\n\n    /**\n     * @notice              Returns whether the account is allowed to use the handle, either due to\n     *                      allowTransient() or allow().\n     * @param handle        Handle.\n     * @param account       Address of the account.\n     * @return isAllowed    Whether the account can access the handle.\n     */\n    function isAllowed(bytes32 handle, address account) internal view returns (bool) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        return IACL($.ACLAddress).isAllowed(handle, account);\n    }\n\n    /**\n     * @notice              Returns whether the handle is allowed to be publicly decrypted.\n     * @param handle        Handle.\n     * @return isAllowed    Whether the handle can be publicly decrypted.\n     */\n    function isPubliclyDecryptable(bytes32 handle) internal view returns (bool) {\n        CoprocessorConfig storage $ = getCoprocessorConfig();\n        return IACL($.ACLAddress).isAllowedForDecryption(handle);\n    }\n}\n"
    },
    "@openzeppelin/confidential-contracts/interfaces/IConfidentialFungibleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (interfaces/IConfidentialFungibleToken.sol)\npragma solidity ^0.8.24;\n\nimport {euint64, externalEuint64} from \"@fhevm/solidity/lib/FHE.sol\";\n\n/// @dev Draft interface for a confidential fungible token standard utilizing the Zama FHE library.\ninterface IConfidentialFungibleToken {\n    /**\n     * @dev Emitted when the expiration timestamp for an operator `operator` is updated for a given `holder`.\n     * The operator may move any amount of tokens on behalf of the holder until the timestamp `until`.\n     */\n    event OperatorSet(address indexed holder, address indexed operator, uint48 until);\n\n    /// @dev Emitted when a confidential transfer is made from `from` to `to` of encrypted amount `amount`.\n    event ConfidentialTransfer(address indexed from, address indexed to, euint64 indexed amount);\n\n    /**\n     * @dev Emitted when an encrypted amount is disclosed.\n     *\n     * Accounts with access to the encrypted amount `encryptedAmount` that is also accessible to this contract\n     * should be able to disclose the amount. This functionality is implementation specific.\n     */\n    event AmountDisclosed(euint64 indexed encryptedAmount, uint64 amount);\n\n    /// @dev Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @dev Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @dev Returns the number of decimals of the token. Recommended to be 6.\n    function decimals() external view returns (uint8);\n\n    /// @dev Returns the token URI.\n    function tokenURI() external view returns (string memory);\n\n    /// @dev Returns the confidential total supply of the token.\n    function confidentialTotalSupply() external view returns (euint64);\n\n    /// @dev Returns the confidential balance of the account `account`.\n    function confidentialBalanceOf(address account) external view returns (euint64);\n\n    /// @dev Returns true if `spender` is currently an operator for `holder`.\n    function isOperator(address holder, address spender) external view returns (bool);\n\n    /**\n     * @dev Sets `operator` as an operator for `holder` until the timestamp `until`.\n     *\n     * NOTE: An operator may transfer any amount of tokens on behalf of a holder while approved.\n     */\n    function setOperator(address operator, uint48 until) external;\n\n    /**\n     * @dev Transfers the encrypted amount `encryptedAmount` to `to` with the given input proof `inputProof`.\n     *\n     * Returns the encrypted amount that was actually transferred.\n     */\n    function confidentialTransfer(\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof\n    ) external returns (euint64);\n\n    /**\n     * @dev Similar to {confidentialTransfer-address-externalEuint64-bytes} but without an input proof. The caller\n     * *must* already be allowed by ACL for the given `amount`.\n     */\n    function confidentialTransfer(address to, euint64 amount) external returns (euint64 transferred);\n\n    /**\n     * @dev Transfers the encrypted amount `encryptedAmount` from `from` to `to` with the given input proof\n     * `inputProof`. `msg.sender` must be either `from` or an operator for `from`.\n     *\n     * Returns the encrypted amount that was actually transferred.\n     */\n    function confidentialTransferFrom(\n        address from,\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof\n    ) external returns (euint64);\n\n    /**\n     * @dev Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but without an input proof.\n     * The caller *must* be already allowed by ACL for the given `amount`.\n     */\n    function confidentialTransferFrom(address from, address to, euint64 amount) external returns (euint64 transferred);\n\n    /**\n     * @dev Similar to {confidentialTransfer-address-externalEuint64-bytes} but with a callback to `to` after\n     * the transfer.\n     *\n     * The callback is made to the {IConfidentialFungibleTokenReceiver-onConfidentialTransferReceived} function on the\n     * to address with the actual transferred amount (may differ from the given `encryptedAmount`) and the given\n     * data `data`.\n     */\n    function confidentialTransferAndCall(\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof,\n        bytes calldata data\n    ) external returns (euint64 transferred);\n\n    /// @dev Similar to {confidentialTransfer-address-euint64} but with a callback to `to` after the transfer.\n    function confidentialTransferAndCall(\n        address to,\n        euint64 amount,\n        bytes calldata data\n    ) external returns (euint64 transferred);\n\n    /**\n     * @dev Similar to {confidentialTransferFrom-address-address-externalEuint64-bytes} but with a callback to `to`\n     * after the transfer.\n     */\n    function confidentialTransferFromAndCall(\n        address from,\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof,\n        bytes calldata data\n    ) external returns (euint64 transferred);\n\n    /**\n     * @dev Similar to {confidentialTransferFrom-address-address-euint64} but with a callback to `to`\n     * after the transfer.\n     *\n     */\n    function confidentialTransferFromAndCall(\n        address from,\n        address to,\n        euint64 amount,\n        bytes calldata data\n    ) external returns (euint64 transferred);\n}\n"
    },
    "@openzeppelin/confidential-contracts/interfaces/IConfidentialFungibleTokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (interfaces/IConfidentialFungibleTokenReceiver.sol)\npragma solidity ^0.8.24;\n\nimport {ebool, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\n\n/// @dev Interface for contracts that can receive confidential token transfers with a callback.\ninterface IConfidentialFungibleTokenReceiver {\n    /**\n     * @dev Called upon receiving a confidential token transfer. Returns an encrypted boolean indicating success\n     * of the callback. If false is returned, the transfer must be reversed.\n     */\n    function onConfidentialTransferReceived(\n        address operator,\n        address from,\n        euint64 amount,\n        bytes calldata data\n    ) external returns (ebool);\n}\n"
    },
    "@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (token/ConfidentialFungibleToken.sol)\npragma solidity ^0.8.27;\n\nimport {FHE, externalEuint64, ebool, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {IConfidentialFungibleToken} from \"./../interfaces/IConfidentialFungibleToken.sol\";\nimport {FHESafeMath} from \"./../utils/FHESafeMath.sol\";\nimport {ConfidentialFungibleTokenUtils} from \"./utils/ConfidentialFungibleTokenUtils.sol\";\n\n/**\n * @dev Reference implementation for {IConfidentialFungibleToken}.\n *\n * This contract implements a fungible token where balances and transfers are encrypted using the Zama fhEVM,\n * providing confidentiality to users. Token amounts are stored as encrypted, unsigned integers (`euint64`)\n * that can only be decrypted by authorized parties.\n *\n * Key features:\n *\n * - All balances are encrypted\n * - Transfers happen without revealing amounts\n * - Support for operators (delegated transfer capabilities with time bounds)\n * - Transfer and call pattern\n * - Safe overflow/underflow handling for FHE operations\n */\nabstract contract ConfidentialFungibleToken is IConfidentialFungibleToken {\n    mapping(address holder => euint64) private _balances;\n    mapping(address holder => mapping(address spender => uint48)) private _operators;\n    mapping(uint256 requestId => euint64 encryptedAmount) private _requestHandles;\n    euint64 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    string private _tokenURI;\n\n    /// @dev The given receiver `receiver` is invalid for transfers.\n    error ConfidentialFungibleTokenInvalidReceiver(address receiver);\n\n    /// @dev The given sender `sender` is invalid for transfers.\n    error ConfidentialFungibleTokenInvalidSender(address sender);\n\n    /// @dev The given holder `holder` is not authorized to spend on behalf of `spender`.\n    error ConfidentialFungibleTokenUnauthorizedSpender(address holder, address spender);\n\n    /// @dev The holder `holder` is trying to send tokens but has a balance of 0.\n    error ConfidentialFungibleTokenZeroBalance(address holder);\n\n    /**\n     * @dev The caller `user` does not have access to the encrypted amount `amount`.\n     *\n     * NOTE: Try using the equivalent transfer function with an input proof.\n     */\n    error ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(euint64 amount, address user);\n\n    /// @dev The given caller `caller` is not authorized for the current operation.\n    error ConfidentialFungibleTokenUnauthorizedCaller(address caller);\n\n    /// @dev The given gateway request ID `requestId` is invalid.\n    error ConfidentialFungibleTokenInvalidGatewayRequest(uint256 requestId);\n\n    constructor(string memory name_, string memory symbol_, string memory tokenURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        _tokenURI = tokenURI_;\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function decimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function tokenURI() public view virtual returns (string memory) {\n        return _tokenURI;\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTotalSupply() public view virtual returns (euint64) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialBalanceOf(address account) public view virtual returns (euint64) {\n        return _balances[account];\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function isOperator(address holder, address spender) public view virtual returns (bool) {\n        return holder == spender || block.timestamp <= _operators[holder][spender];\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function setOperator(address operator, uint48 until) public virtual {\n        _setOperator(msg.sender, operator, until);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransfer(\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof\n    ) public virtual returns (euint64) {\n        return _transfer(msg.sender, to, FHE.fromExternal(encryptedAmount, inputProof));\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransfer(address to, euint64 amount) public virtual returns (euint64) {\n        require(\n            FHE.isAllowed(amount, msg.sender),\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\n        );\n        return _transfer(msg.sender, to, amount);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransferFrom(\n        address from,\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof\n    ) public virtual returns (euint64 transferred) {\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\n        transferred = _transfer(from, to, FHE.fromExternal(encryptedAmount, inputProof));\n        FHE.allowTransient(transferred, msg.sender);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransferFrom(\n        address from,\n        address to,\n        euint64 amount\n    ) public virtual returns (euint64 transferred) {\n        require(\n            FHE.isAllowed(amount, msg.sender),\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\n        );\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\n        transferred = _transfer(from, to, amount);\n        FHE.allowTransient(transferred, msg.sender);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransferAndCall(\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof,\n        bytes calldata data\n    ) public virtual returns (euint64 transferred) {\n        transferred = _transferAndCall(msg.sender, to, FHE.fromExternal(encryptedAmount, inputProof), data);\n        FHE.allowTransient(transferred, msg.sender);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransferAndCall(\n        address to,\n        euint64 amount,\n        bytes calldata data\n    ) public virtual returns (euint64 transferred) {\n        require(\n            FHE.isAllowed(amount, msg.sender),\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\n        );\n        transferred = _transferAndCall(msg.sender, to, amount, data);\n        FHE.allowTransient(transferred, msg.sender);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransferFromAndCall(\n        address from,\n        address to,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof,\n        bytes calldata data\n    ) public virtual returns (euint64 transferred) {\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\n        transferred = _transferAndCall(from, to, FHE.fromExternal(encryptedAmount, inputProof), data);\n        FHE.allowTransient(transferred, msg.sender);\n    }\n\n    /// @inheritdoc IConfidentialFungibleToken\n    function confidentialTransferFromAndCall(\n        address from,\n        address to,\n        euint64 amount,\n        bytes calldata data\n    ) public virtual returns (euint64 transferred) {\n        require(\n            FHE.isAllowed(amount, msg.sender),\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(amount, msg.sender)\n        );\n        require(isOperator(from, msg.sender), ConfidentialFungibleTokenUnauthorizedSpender(from, msg.sender));\n        transferred = _transferAndCall(from, to, amount, data);\n        FHE.allowTransient(transferred, msg.sender);\n    }\n\n    /**\n     * @dev Discloses an encrypted amount `encryptedAmount` publicly via an {IConfidentialFungibleToken-AmountDisclosed}\n     * event. The caller and this contract must be authorized to use the encrypted amount on the ACL.\n     *\n     * NOTE: This is an asynchronous operation where the actual decryption happens off-chain and\n     * {finalizeDiscloseEncryptedAmount} is called with the result.\n     */\n    function discloseEncryptedAmount(euint64 encryptedAmount) public virtual {\n        require(\n            FHE.isAllowed(encryptedAmount, msg.sender) && FHE.isAllowed(encryptedAmount, address(this)),\n            ConfidentialFungibleTokenUnauthorizedUseOfEncryptedAmount(encryptedAmount, msg.sender)\n        );\n\n        bytes32[] memory cts = new bytes32[](1);\n        cts[0] = euint64.unwrap(encryptedAmount);\n        uint256 requestID = FHE.requestDecryption(cts, this.finalizeDiscloseEncryptedAmount.selector);\n        _requestHandles[requestID] = encryptedAmount;\n    }\n\n    /// @dev Finalizes a disclose encrypted amount request.\n    function finalizeDiscloseEncryptedAmount(\n        uint256 requestId,\n        bytes calldata cleartexts,\n        bytes calldata decryptionProof\n    ) public virtual {\n        FHE.checkSignatures(requestId, cleartexts, decryptionProof);\n\n        euint64 requestHandle = _requestHandles[requestId];\n        require(FHE.isInitialized(requestHandle), ConfidentialFungibleTokenInvalidGatewayRequest(requestId));\n        emit AmountDisclosed(requestHandle, abi.decode(cleartexts, (uint64)));\n\n        _requestHandles[requestId] = euint64.wrap(0);\n    }\n\n    function _setOperator(address holder, address operator, uint48 until) internal virtual {\n        _operators[holder][operator] = until;\n        emit OperatorSet(holder, operator, until);\n    }\n\n    function _mint(address to, euint64 amount) internal returns (euint64 transferred) {\n        require(to != address(0), ConfidentialFungibleTokenInvalidReceiver(address(0)));\n        return _update(address(0), to, amount);\n    }\n\n    function _burn(address from, euint64 amount) internal returns (euint64 transferred) {\n        require(from != address(0), ConfidentialFungibleTokenInvalidSender(address(0)));\n        return _update(from, address(0), amount);\n    }\n\n    function _transfer(address from, address to, euint64 amount) internal returns (euint64 transferred) {\n        require(from != address(0), ConfidentialFungibleTokenInvalidSender(address(0)));\n        require(to != address(0), ConfidentialFungibleTokenInvalidReceiver(address(0)));\n        return _update(from, to, amount);\n    }\n\n    function _transferAndCall(\n        address from,\n        address to,\n        euint64 amount,\n        bytes calldata data\n    ) internal returns (euint64 transferred) {\n        // Try to transfer amount + replace input with actually transferred amount.\n        euint64 sent = _transfer(from, to, amount);\n\n        // Perform callback\n        ebool success = ConfidentialFungibleTokenUtils.checkOnTransferReceived(msg.sender, from, to, sent, data);\n\n        // Try to refund if callback fails\n        euint64 refund = _update(to, from, FHE.select(success, FHE.asEuint64(0), sent));\n        transferred = FHE.sub(sent, refund);\n    }\n\n    function _update(address from, address to, euint64 amount) internal virtual returns (euint64 transferred) {\n        ebool success;\n        euint64 ptr;\n\n        if (from == address(0)) {\n            (success, ptr) = FHESafeMath.tryIncrease(_totalSupply, amount);\n            FHE.allowThis(ptr);\n            _totalSupply = ptr;\n        } else {\n            euint64 fromBalance = _balances[from];\n            require(FHE.isInitialized(fromBalance), ConfidentialFungibleTokenZeroBalance(from));\n            (success, ptr) = FHESafeMath.tryDecrease(fromBalance, amount);\n            FHE.allowThis(ptr);\n            FHE.allow(ptr, from);\n            _balances[from] = ptr;\n        }\n\n        transferred = FHE.select(success, amount, FHE.asEuint64(0));\n\n        if (to == address(0)) {\n            ptr = FHE.sub(_totalSupply, transferred);\n            FHE.allowThis(ptr);\n            _totalSupply = ptr;\n        } else {\n            ptr = FHE.add(_balances[to], transferred);\n            FHE.allowThis(ptr);\n            FHE.allow(ptr, to);\n            _balances[to] = ptr;\n        }\n\n        if (from != address(0)) FHE.allow(transferred, from);\n        if (to != address(0)) FHE.allow(transferred, to);\n        FHE.allowThis(transferred);\n        emit ConfidentialTransfer(from, to, transferred);\n    }\n}\n"
    },
    "@openzeppelin/confidential-contracts/token/utils/ConfidentialFungibleTokenUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (token/utils/ConfidentialFungibleTokenUtils.sol)\npragma solidity ^0.8.24;\n\nimport {FHE, ebool, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\n\nimport {IConfidentialFungibleTokenReceiver} from \"../../interfaces/IConfidentialFungibleTokenReceiver.sol\";\nimport {ConfidentialFungibleToken} from \"../ConfidentialFungibleToken.sol\";\n\n/// @dev Library that provides common {ConfidentialFungibleToken} utility functions.\nlibrary ConfidentialFungibleTokenUtils {\n    /**\n     * @dev Performs a transfer callback to the recipient of the transfer `to`. Should be invoked\n     * after all transfers \"withCallback\" on a {ConfidentialFungibleToken}.\n     *\n     * The transfer callback is not invoked on the recipient if the recipient has no code (i.e. is an EOA). If the\n     * recipient has non-zero code, it must implement\n     * {IConfidentialFungibleTokenReceiver-onConfidentialTransferReceived} and return an `ebool` indicating\n     * whether the transfer was accepted or not. If the `ebool` is `false`, the transfer will be reversed.\n     */\n    function checkOnTransferReceived(\n        address operator,\n        address from,\n        address to,\n        euint64 amount,\n        bytes calldata data\n    ) internal returns (ebool) {\n        if (to.code.length > 0) {\n            try\n                IConfidentialFungibleTokenReceiver(to).onConfidentialTransferReceived(operator, from, amount, data)\n            returns (ebool retval) {\n                return retval;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ConfidentialFungibleToken.ConfidentialFungibleTokenInvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return FHE.asEbool(true);\n        }\n    }\n}\n"
    },
    "@openzeppelin/confidential-contracts/utils/FHESafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Confidential Contracts (last updated v0.2.0) (utils/FHESafeMath.sol)\npragma solidity ^0.8.24;\n\nimport {FHE, ebool, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\n\n/**\n * @dev Library providing safe arithmetic operations for encrypted values\n * to handle potential overflows in FHE operations.\n */\nlibrary FHESafeMath {\n    /**\n     * @dev Try to increase the encrypted value `oldValue` by `delta`. If the operation is successful,\n     * `success` will be true and `updated` will be the new value. Otherwise, `success` will be false\n     * and `updated` will be the original value.\n     */\n    function tryIncrease(euint64 oldValue, euint64 delta) internal returns (ebool success, euint64 updated) {\n        if (!FHE.isInitialized(oldValue)) {\n            success = FHE.asEbool(true);\n            updated = delta;\n        } else {\n            euint64 newValue = FHE.add(oldValue, delta);\n            success = FHE.ge(newValue, oldValue);\n            updated = FHE.select(success, newValue, oldValue);\n        }\n    }\n\n    /**\n     * @dev Try to decrease the encrypted value `oldValue` by `delta`. If the operation is successful,\n     * `success` will be true and `updated` will be the new value. Otherwise, `success` will be false\n     * and `updated` will be the original value.\n     */\n    function tryDecrease(euint64 oldValue, euint64 delta) internal returns (ebool success, euint64 updated) {\n        success = FHE.ge(oldValue, delta);\n        updated = FHE.select(success, FHE.sub(oldValue, delta), oldValue);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\naddress constant SepoliaZamaOracleAddress = 0xa02Cda4Ca3a71D7C46997716F4283aa851C28812;\n"
    },
    "contracts/access/ACLManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {IACLManager} from \"../interfaces/IACLManager.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract ACLManager is IACLManager, AccessControl {\n    // Role definitions\n    bytes32 public constant POOL_ADMIN = keccak256(\"POOL_ADMIN\");\n    bytes32 public constant EMERGENCY_ADMIN = keccak256(\"EMERGENCY_ADMIN\");\n    bytes32 public constant RISK_ADMIN = keccak256(\"RISK_ADMIN\");\n    \n    constructor(address initialOwner) {\n        // Grant the initial owner the DEFAULT_ADMIN_ROLE\n        _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);\n        \n        // Grant the initial owner the POOL_ADMIN role\n        _grantRole(POOL_ADMIN, initialOwner);\n        \n        _setRoleAdmin(POOL_ADMIN, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(EMERGENCY_ADMIN, DEFAULT_ADMIN_ROLE);\n        _setRoleAdmin(RISK_ADMIN, DEFAULT_ADMIN_ROLE);\n    }\n    \n    // Convenience functions for checking specific roles\n    function isPoolAdmin(address account) public view override returns (bool) {\n        return hasRole(POOL_ADMIN, account);\n    }\n\n    function isEmergencyAdmin(address account) public view override returns (bool) {\n        return hasRole(EMERGENCY_ADMIN, account);\n    }\n\n    function isRiskAdmin(address account) public view override returns (bool) {\n        return hasRole(RISK_ADMIN, account);\n    }\n    \n    // Inherits grantRole and revokeRole from AccessControl\n}"
    },
    "contracts/config/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nlibrary Constants {\n    // ========== PRECISION STANDARDS ==========\n\n    uint64 internal constant VALUE_PRECISION_FACTOR = 1e6; // 6 decimals\n    uint64 internal constant PERCENT_PRECISION = 10000; // 4 decimals (Basis Points)\n\n\n    uint64 internal constant DEFAULT_COLLATERAL_FACTOR = 7500; \n    uint64 internal constant DEFAULT_LIQUIDITY_RATE = 300; \n    uint64 internal constant DEFAULT_BORROW_RATE = 500; \n\n    uint64 internal constant DEFAULT_BASE_RATE = 200;\n    uint64 internal constant DEFAULT_MULTIPLIER = 1000;\n    uint64 internal constant DEFAULT_JUMP_MULTIPLIER = 30000; \n    uint64 internal constant DEFAULT_KINK = 8000;\n\n    // ========== RATE SAFETY LIMITS (In Basis Points) ==========\n    uint64 internal constant MAX_BORROW_RATE = 5000;     \n    uint64 internal constant MIN_BORROW_RATE = 100;     \n    uint64 internal constant MIN_LIQUIDITY_RATE = 50;       \n\n    // ========== INTEREST RATE MODEL SAFETY BOUNDS (In Basis Points) ==========\n    uint64 internal constant MAX_BASE_RATE = 1000;       \n    uint64 internal constant MAX_MULTIPLIER = 5000;     \n    uint64 internal constant MAX_JUMP_MULTIPLIER = 50000;\n    uint64 internal constant MIN_KINK = 5000;      \n    uint64 internal constant MAX_KINK = 9000;  \n\n    // ========== ADDITIONAL SAFETY CONSTANTS (In Basis Points) ==========\n    uint64 internal constant MAX_RESERVE_FACTOR = 3000;  \n\n    uint64 internal constant MIN_COLLATERAL_FACTOR = 1000; \n    uint64 internal constant MAX_COLLATERAL_FACTOR = 9000; \n\n    // ========== TIME CONSTANTS ==========\n    uint64 internal constant MIN_TIME_ELAPSED = 1 hours;\n    uint64 internal constant MAX_ACCRUAL_PERIOD = 90 days;\n    uint64 internal constant MIN_COMPOUNDING_PERIOD = 1 days;\n    uint64 internal constant SECONDS_PER_YEAR = 365 days;\n\n    uint64 internal constant MAX_EUINT64 = type(uint64).max;\n\n    // ========== ROLE IDENTIFIERS ==========\n    bytes32 internal constant POOL_ADMIN = keccak256(\"POOL_ADMIN\");\n    bytes32 internal constant EMERGENCY_ADMIN = keccak256(\"EMERGENCY_ADMIN\");\n    bytes32 internal constant RISK_ADMIN = keccak256(\"RISK_ADMIN\");\n}"
    },
    "contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ninterface IACLManager is IAccessControl {\n    // Role constants\n    function POOL_ADMIN() external view returns (bytes32);\n    function EMERGENCY_ADMIN() external view returns (bytes32);\n    function RISK_ADMIN() external view returns (bytes32);\n    \n    // Convenience functions for checking specific roles\n    function isPoolAdmin(address account) external view returns (bool);\n    function isEmergencyAdmin(address account) external view returns (bool);\n    function isRiskAdmin(address account) external view returns (bool);\n}"
    },
    "contracts/interfaces/IConfidentialLendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {euint64, externalEuint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {Types} from \"../libraries/Types.sol\";\n\ninterface IConfidentialLendingPool {\n    // User operations\n    function supply(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof\n    ) external;\n\n    function withdraw(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof\n    ) external;\n\n    function borrow(\n        address asset, \n        externalEuint64 amount,\n        bytes calldata inputProof\n    ) external;\n\n    function repay(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof,\n        bool isRepayingAll\n    ) external;\n\n    // Per-user collateral toggle\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    // Configuration functions (called by configurator)\n    function initReserve(\n        address asset,\n        bool borrowingEnabled,\n        bool isCollateral,\n        uint64 collateralFactor\n    ) external;\n\n    function updateReserveConfig(\n        address asset,\n        bool active,\n        bool borrowingEnabled,\n        bool isCollateral,\n        uint64 collateralFactor,\n        uint64 supplyCap,\n        uint64 borrowCap\n    ) external;\n\n    // View functions\n    function getUserSuppliedBalance(address user, address asset) external view returns (euint64);\n    function getUserBorrowedBalance(address user, address asset) external view returns (euint64);\n    function getUserPosition(address user) external view returns (Types.ConfidentialUserPosition memory);\n\n    // Events\n    event Supply(address indexed reserve, address indexed user);\n    event Withdraw(address indexed reserve, address indexed user);\n    event Borrow(address indexed reserve, address indexed user);\n    event Repay(address indexed reserve, address indexed user);\n}\n"
    },
    "contracts/interfaces/IConfidentialLendingPoolView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {euint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {Types} from \"../libraries/Types.sol\";\n\ninterface IConfidentialLendingPoolView {\n    function getUserSuppliedBalance(address user, address asset) external view returns (euint64);\n    function getUserBorrowedBalance(address user, address asset) external view returns (euint64);\n    function getUserPosition(address user) external view returns (Types.ConfidentialUserPosition memory);\n    function getReserveData(address asset) external view returns (Types.ConfidentialReserve memory);\n    function getReserveList() external view returns (address[] memory);\n}"
    },
    "contracts/interfaces/IConfidentialPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {Types} from \"../libraries/Types.sol\";\n\ninterface IConfidentialPoolConfigurator {\n    function setLendingPool(address _lendingPool) external;\n\n    function initReserve(\n        address asset,\n        bool borrowingEnabled,\n        bool isCollateral,\n        uint64 collateralFactor\n    ) external;\n\n    function setReserveActive(address asset, bool active) external;\n    function setReserveBorrowing(address asset, bool enabled) external;\n    function setReserveCollateral(address asset, bool enabled) external;\n    function setCollateralFactor(address asset, uint64 factor) external;\n\n    function getReserveConfig(address asset) external view returns (Types.ConfidentialReserve memory);\n\n    function setSupplyCap(address asset, uint64 cap) external;\n    function setBorrowCap(address asset, uint64 cap) external;\n\n    function pauseReserve(address asset) external;\n    function unpauseReserve(address asset) external;\n\n    event ReserveInitialized(address indexed asset, bool borrowingEnabled, bool isCollateral);\n    event ReserveActiveChanged(address indexed asset, bool active);\n    event ReserveBorrowingChanged(address indexed asset, bool enabled);\n    event ReserveCollateralChanged(address indexed asset, bool enabled);\n    event CollateralFactorUpdated(address indexed asset, uint64 factor);\n    event SupplyCapUpdated(address indexed asset, uint64 cap);\n    event BorrowCapUpdated(address indexed asset, uint64 cap);\n    event ReservePaused(address indexed asset);\n    event ReserveUnpaused(address indexed asset);\n}"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IPriceOracle {\n    function getPrice(address asset) external view returns (uint64);\n    function getAssetPrice(address asset) external view returns (uint64);\n    function setPrice(address asset, uint64 price) external;\n    function updatePrice(address asset, uint64 price) external;\n\n    event PriceUpdated(address indexed asset, uint64 price);\n}"
    },
    "contracts/libraries/AssetUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FHE, euint64, euint128} from \"@fhevm/solidity/lib/FHE.sol\";\n\nlibrary AssetUtils {\n\n    /**\n     * @notice Converts a raw token amount into its 12-decimal normalized USD value.\n     * @param amount The token balance as an euint64 (respecting OZ's standard).\n     * @param price The token's price, normalized to 12 decimals.\n     * @param decimals The *actual* decimals of the token (e.g., 6 for cUSDC, 18 for cWETH).\n     * @return The 12-decimal normalized USD value as an euint128.\n     */\n    function getUsdValue(\n        euint64 amount,\n        uint128 price,\n        uint8 decimals\n    ) internal returns (euint128) {\n        if (decimals > 38 || price == 0) {\n            return FHE.asEuint128(0);\n        }\n\n        euint128 amount128 = FHE.asEuint128(amount);\n        euint128 price128 = FHE.asEuint128(price);\n        uint128 denominator = uint128(10)**uint128(decimals);\n        \n        if (denominator == 0) {\n            return FHE.asEuint128(0); \n        }\n\n        euint128 usdValue = FHE.mul(amount128, price128);\n        usdValue = FHE.div(usdValue, denominator); // div by plaintext\n\n        return usdValue;\n    }\n}"
    },
    "contracts/libraries/AssetUtils64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FHE, euint64, ebool} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {SafeFHEOperations} from \"./SafeFHEOperations.sol\";\nimport \"../config/Constants.sol\"; \n\nlibrary AssetUtils64 {\n    using FHE for euint64;\n    using SafeFHEOperations for euint64;\n\n    /**\n     * @notice Converts a 6-decimal normalized token amount into its 6-decimal USD value.\n     * @param amountE6 The token balance normalized to 6 decimals.\n     * @param priceE6 The token's price, normalized to 6 decimals.\n     * @return The 6-decimal USD value as an euint64.\n     * @dev WARNING: Intermediate multiplication might overflow euint64!\n     * Calculates: (amount_e6 * price_e6) / 10^6\n     */\n    function getUsdValue64(euint64 amountE6,uint64 priceE6) internal returns (euint64) {\n        if (priceE6 == 0) {\n            return FHE.asEuint64(0);\n        }\n\n        uint64 precisionFactor = Constants.VALUE_PRECISION_FACTOR;\n        euint64 usdValue = FHE.mul(amountE6, priceE6);\n        usdValue = FHE.div(usdValue, precisionFactor); \n\n        return usdValue; // Result is 6-decimal USD\n    }\n}"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/// @title ErrorsLib\n/// @notice Centralized library for reusable custom errors across the protocol.\n/// @author Nexora Protocol\nlibrary ErrorsLib {\n    /// @notice Caller is not authorized to perform the requested action.\n    error OnlyPoolConfigurator();\n\n    /// @notice Caller is not authorized to perform the requested action.\n    error OnlyPoolAdmin();\n\n    /// @notice Caller is not authorized to perform the requested action.\n    error OnlyEmergencyAdmin();\n\n    /// @notice Protocol is currently paused.\n    error ProtocolPaused();\n\n    /// @notice The reserve is not active.\n    error ReserveNotActive();\n\n    /// @notice Borrowing is not enabled for this reserve.\n    error BorrowingNotEnabled();\n\n    /// @notice Address parameter is the zero address.\n    error ZeroAddress();\n\n    /// @notice The reserve is not collateral.\n    error ReserveNotCollateral();\n\n    /// @notice Protocol is already paused.\n    error ProtocolAlreadyPaused();\n\n    /// @notice Protocol is not paused.\n    error ProtocolNotPaused();\n\n    /// @notice No collateral is enabled.\n    error NoCollateralEnabled();\n\n    /// @notice Multiple debts are not allowed.\n    error MultipleDebtsNotAllowed();\n\n    /// @notice Oracle price is zero.\n    error OraclePriceZero();\n\n    /// @notice Invalid debt repayment.\n    error InvalidDebtRepayment();\n\n    /// @notice Not the designated collateral.\n    error NotTheDesignatedCollateral();\n\n    /// @notice Reserve is already initialized.\n    error ReserveAlreadyInitialized();\n\n    /// @notice Reserve is not initialized.\n    error ReserveNotInitialized();\n}"
    },
    "contracts/libraries/SafeFHEOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FHE, euint64, ebool} from \"@fhevm/solidity/lib/FHE.sol\";\nimport \"../config/Constants.sol\";\n\n/**\n * @title SafeFHEOperations\n * @notice Gas-efficient FHE operations using FHE.select\n * @dev Avoids expensive FHE decrptions \n */\nlibrary SafeFHEOperations {\n    using FHE for euint64;\n    using FHE for ebool;\n\n    /**\n     * @notice Validates and caps an encrypted amount against allowed bounds\n     * @dev Ensures amount is non-negative and within maximum limit. Returns original amount if valid, otherwise returns zero.\n     * @param amount Encrypted amount to validate\n     * @param maxAllowed Maximum allowed encrypted amount\n     * @return safeAmount Original amount if 0 <= amount <= maxAllowed, otherwise zero\n     */\n    function validateAndCap(euint64 amount, euint64 maxAllowed) internal returns (euint64) {\n        ebool isNonNegative = amount.ge(FHE.asEuint64(0));\n        ebool isWithinLimit = amount.le(maxAllowed);\n        ebool isValid = isNonNegative.and(isWithinLimit);\n        \n        return FHE.select(isValid, amount, FHE.asEuint64(0));\n    }\n\n    /**\n     * @notice Safely subtract with underflow protection\n     * @dev Returns zero if underflow would occur\n     * @param a Minuend\n     * @param b Subtrahend\n     * @return result Safe subtraction result\n     */\n    function safeSub(euint64 a, euint64 b) internal returns (euint64) {\n        ebool willUnderflow = FHE.gt(b, a);\n        return FHE.select(willUnderflow, FHE.asEuint64(0), FHE.sub(a, b));\n    }\n\n    /**\n     * @notice Safely add with overflow protection\n     * @dev Returns zero if overflow would occur\n     * @param a First operand\n     * @param b Second operand\n     * @return result Safe addition result\n     */\n    function safeAdd(euint64 a, euint64 b) internal returns (euint64) {\n        euint64 temp = FHE.add(a, b);\n        ebool hasOverflow = FHE.lt(temp, a);\n        return FHE.select(hasOverflow, FHE.asEuint64(0), temp);\n    }\n\n    /**\n     * @notice Safely multiply an encrypted value by a plaintext value.\n     * @dev Checks for overflow. Returns zero if overflow would occur.\n     * @param a Encrypted operand\n     * @param b Plaintext operand (uint64)\n     * @return result Safe multiplication result\n     */\n    function safeMul(euint64 a, uint64 b) internal returns (euint64) {\n        if (b == 0) {\n            return FHE.asEuint64(0);\n        }\n        euint64 c = FHE.mul(a, b);\n        return c;\n    }\n\n    /**\n     * @notice Safely divide an encrypted value by a plaintext value.\n     * @dev Protects against division by zero.\n     * @param a Encrypted numerator\n     * @param b Plaintext denominator (uint64)\n     * @return result Safe division result\n     */\n    function safeDiv(euint64 a, uint64 b) internal returns (euint64) {\n        if (b == 0) {\n            return FHE.asEuint64(0);\n        }\n        return FHE.div(a, b);\n    }\n\n    /**\n     * @notice Check if amount is sufficient for operation\n     * @dev Returns 1 if sufficient, 0 if not (for use in calculations)\n     * @param amount Requested amount\n     * @param balance Available balance\n     * @return flag 1 if sufficient, 0 if not\n     */\n    function isSufficient(euint64 amount, euint64 balance) internal returns (euint64) {\n        ebool sufficient = FHE.le(amount, balance);\n        return FHE.select(sufficient, FHE.asEuint64(1), FHE.asEuint64(0));\n    }\n    \n    /**\n     * @notice Ensure value is initialized\n     * @dev Returns 0 if not initialized, otherwise returns original value\n     * @param value The value to check\n     * @return initializedValue The initialized value\n     */\n    function ensureInitialized(euint64 value) internal returns (euint64) {\n        bool isInit = FHE.isInitialized(value);\n        if (isInit) {\n            return value;\n        }\n        return FHE.asEuint64(0);\n    }\n}\n"
    },
    "contracts/libraries/SafeMath64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title SafeMath64\n * @notice Safe math operations for uint64 to prevent overflow/underflow\n * @dev Inspired by OpenZeppelin SafeMath and Aave's math libraries\n * \n * Usage:\n * - For plaintext uint64 operations (prices, factors, caps, etc.)\n * - Complements SafeFHEOperations (which is for encrypted euint64)\n * \n * Why uint64?\n * - Matches euint64 encrypted type\n * - Future upgrade path to uint256/euint256\n * - Gas efficient for storage\n */\nlibrary SafeMath64 {\n    \n    /**\n     * @notice Safely multiply two values and divide by precision\n     * @dev Uses uint256 intermediate calculation to prevent overflow\n     * @dev This is the PRIMARY function for fixed-point multiplication\n     * \n     * Example: mulDiv(2000e12, 0.75e12, 1e12) = 1500e12\n     * (price * collateralFactor / PRECISION)\n     * \n     * @param a First operand (e.g., collateral price)\n     * @param b Second operand (e.g., collateral factor)\n     * @param denominator Divisor (e.g., PRECISION = 1e12)\n     * @return result a * b / denominator (safely)\n     */\n    function mulDiv(uint64 a, uint64 b, uint64 denominator) internal pure returns (uint64) {\n        require(denominator > 0, \"SafeMath64: division by zero\");\n        \n        // Use uint256 to prevent overflow during multiplication\n        uint256 product = uint256(a) * uint256(b);\n        uint256 result = product / uint256(denominator);\n        \n        // Ensure result fits in uint64\n        require(result <= type(uint64).max, \"SafeMath64: mulDiv overflow\");\n        \n        return uint64(result);\n    }\n    \n    /**\n     * @notice Safely multiply two uint64 values\n     * @dev Checks for overflow using uint256 intermediate\n     * @param a First operand\n     * @param b Second operand\n     * @return result a * b (safely)\n     */\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n        // Gas optimization: if a is 0, result is 0\n        if (a == 0) {\n            return 0;\n        }\n        \n        uint256 c = uint256(a) * uint256(b);\n        require(c <= type(uint64).max, \"SafeMath64: multiplication overflow\");\n        \n        return uint64(c);\n    }\n    \n    /**\n     * @notice Safely divide two uint64 values\n     * @dev Prevents division by zero\n     * @param a Numerator\n     * @param b Denominator\n     * @return result a / b (safely)\n     */\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b > 0, \"SafeMath64: division by zero\");\n        return a / b;\n    }\n    \n    /**\n     * @notice Safely add two uint64 values\n     * @dev Checks for overflow\n     * @param a First operand\n     * @param b Second operand\n     * @return result a + b (safely)\n     */\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n        uint64 c = a + b;\n        require(c >= a, \"SafeMath64: addition overflow\");\n        return c;\n    }\n    \n    /**\n     * @notice Safely subtract two uint64 values\n     * @dev Checks for underflow\n     * @param a Minuend\n     * @param b Subtrahend\n     * @return result a - b (safely)\n     */\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b <= a, \"SafeMath64: subtraction underflow\");\n        return a - b;\n    }\n    \n    /**\n     * @notice Calculate percentage of a value\n     * @dev Useful for calculating fees, factors, etc.\n     * @param value Base value\n     * @param percentage Percentage in precision units (e.g., 0.75e12 = 75%)\n     * @param precision Precision divisor (e.g., 1e12)\n     * @return result value * percentage / precision\n     */\n    function percentageOf(uint64 value, uint64 percentage, uint64 precision) internal pure returns (uint64) {\n        return mulDiv(value, percentage, precision);\n    }\n    \n    /**\n     * @notice Get minimum of two values\n     * @param a First value\n     * @param b Second value\n     * @return Minimum value\n     */\n    function min(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n    \n    /**\n     * @notice Get maximum of two values\n     * @param a First value\n     * @param b Second value\n     * @return Maximum value\n     */\n    function max(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a > b ? a : b;\n    }\n}\n\n\n"
    },
    "contracts/libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FHE, euint64, euint128} from \"@fhevm/solidity/lib/FHE.sol\";\n\nlibrary Types {\n\n    /**\n     * @notice Stores the configuration for a single reserve.\n     */\n    struct ConfidentialReserve {\n        address underlyingAsset;\n        euint64 totalSupplied; \n        euint64 totalBorrowed;      \n        euint64 availableLiquidity; \n        uint64 lastUpdateTimestamp;\n        bool active;\n        bool borrowingEnabled;\n        bool isCollateral;\n        bool isPaused;\n        uint64 collateralFactor; \n        uint64 supplyCap;        \n        uint64 borrowCap;        \n        uint8 decimals;        \n    }\n\n    /**\n     * @notice Holds state for a single user in the V0+ model.\n     */\n    struct ConfidentialUserPosition {\n        bool initialized;\n        address currentDebtAsset;\n    }\n\n    /**\n     * @notice Parameters struct for withdrawal operations.\n     */\n    struct WithdrawParams {\n        address asset;\n        euint64 withdrawAmount; \n        euint64 userBalance;  \n        bytes inputProof;\n        address user;\n    }\n\n} "
    },
    "contracts/oracle/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SimplePriceOracle is IPriceOracle, Ownable {\n    mapping(address => uint64) public assetPrices;\n    mapping(address => bool) public isPriceFeed;\n\n   \n    // These are reasonable defaults for testing/development\n    uint64 public constant DEFAULT_USDC_PRICE = 1e6;      \n    uint64 public constant DEFAULT_USDT_PRICE = 1e6;      \n    uint64 public constant DEFAULT_ETH_PRICE = 2000e6;    \n    uint64 public constant DEFAULT_BTC_PRICE = 40000e6;   \n    uint64 public constant DEFAULT_WETH_PRICE = 2000e6;   \n\n    // PriceUpdated event defined in IPriceOracle interface\n    event PriceFeedAdded(address indexed priceFeed);\n    event DefaultPriceUsed(address indexed asset, uint64 defaultPrice);\n\n    modifier onlyPriceFeed() {\n        require(isPriceFeed[msg.sender], \"Only price feed can update prices\");\n        _;\n    }\n\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    function setPrice(address asset, uint64 price) external onlyOwner {\n        assetPrices[asset] = price;\n        emit PriceUpdated(asset, price);\n    }\n\n    function setPriceFeed(address priceFeed, bool enabled) external onlyOwner {\n        isPriceFeed[priceFeed] = enabled;\n        emit PriceFeedAdded(priceFeed);\n    }\n\n    function updatePrice(address asset, uint64 price) external onlyPriceFeed {\n        assetPrices[asset] = price;\n        emit PriceUpdated(asset, price);\n    }\n\n    /**\n     * @notice Get default price for common assets\n     * @dev Returns hardcoded default prices for testing/development\n     * @param asset Asset address\n     * @return price Default price in 1e18 format, or 0 if no default\n     */\n    function getDefaultPrice(address asset) public pure returns (uint64 price) {\n        // For testing/development, we'll use a simple approach:\n        // Return constant prices based on common token patterns\n        \n        // Convert address to uint64 for easier comparison\n        uint64 assetUint = uint64(uint160(asset));\n        \n        // Simple heuristic: use last few digits to determine asset type\n        // This is just for testing \n        \n        uint64 lastDigits = assetUint % 1000;\n        \n        if (lastDigits < 200) {\n            return DEFAULT_USDC_PRICE;\n        } else if (lastDigits < 400) {\n            return DEFAULT_WETH_PRICE;\n        } else if (lastDigits < 600) {\n            return DEFAULT_BTC_PRICE;\n        } else {\n            return DEFAULT_USDC_PRICE;\n        }\n    }\n\n    /**\n     * @notice Get a constant price for any asset (for testing)\n     * @dev Always returns a reasonable default price\n     * @return price Constant price in 1e6 format\n     */\n    function getConstantPrice(address /* asset */) external pure returns (uint64 price) {\n        return DEFAULT_USDC_PRICE;\n    }\n\n    function getPrice(address asset) external view override returns (uint64) {\n        if (assetPrices[asset] > 0) {\n            return assetPrices[asset];\n        }\n        return getDefaultPrice(asset);\n    }\n\n    function getAssetPrice(address asset) external view override returns (uint64) {\n        if (assetPrices[asset] > 0) {\n            return assetPrices[asset];\n        }\n    \n        return getDefaultPrice(asset);\n    }\n\n    /**\n     * @notice Set default prices for common assets\n     * @dev Convenience function to set up common asset prices\n     */\n    function setDefaultPrices() external onlyOwner {\n        emit PriceUpdated(address(0), DEFAULT_USDC_PRICE); \n    }\n}"
    },
    "contracts/protocol/ConfidentialLendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// Interfaces\nimport {IConfidentialLendingPool} from \"../interfaces/IConfidentialLendingPool.sol\";\nimport {IConfidentialLendingPoolView} from \"../interfaces/IConfidentialLendingPoolView.sol\";\nimport {IConfidentialPoolConfigurator} from \"../interfaces/IConfidentialPoolConfigurator.sol\";\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\nimport {SupplyLogic} from \"./logic/SupplyLogic.sol\";\nimport {BorrowLogic} from \"./logic/BorrowLogic.sol\";\nimport {Types} from \"../libraries/Types.sol\";\nimport {ErrorsLib} from \"../libraries/Errors.sol\";\nimport {AssetUtils64} from \"../libraries/AssetUtils64.sol\";\nimport {SafeFHEOperations} from \"../libraries/SafeFHEOperations.sol\"; \nimport {SafeMath64} from \"../libraries/SafeMath64.sol\";\nimport {ACLManager} from \"../access/ACLManager.sol\";\nimport {Constants} from \"../config/Constants.sol\"; \nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport {ConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {FHE, euint64, ebool, externalEuint64} from \"@fhevm/solidity/lib/FHE.sol\";\n\n\ncontract ConfidentialLendingPool is IConfidentialLendingPool, IConfidentialLendingPoolView, ReentrancyGuard, SepoliaConfig {\n\n    using SafeFHEOperations for euint64;\n    using SupplyLogic for Types.ConfidentialReserve;\n    using BorrowLogic for Types.ConfidentialUserPosition;\n    using FHE for euint64;\n    using FHE for ebool;\n    using SafeMath64 for uint64;\n    // ---------------------------------------------\n\n    // Protocol Configuration\n    ACLManager public immutable aclManager;\n    IConfidentialPoolConfigurator public configurator;\n    IPriceOracle public priceOracle;\n    bool public paused;\n\n    address public cethAddress; // The ONLY collateral asset (Set via admin)\n\n\n    // Reserve configuration\n    mapping(address => Types.ConfidentialReserve) public reserves;\n    address[] public reserveList;\n\n    // User Positions (Using simplified Types.ConfidentialUserPosition)\n    mapping(address => mapping(address => euint64)) internal _userSuppliedBalances;\n    mapping(address => mapping(address => euint64)) internal _userBorrowedBalances;\n    mapping(address => Types.ConfidentialUserPosition) internal _userPositions; \n    mapping(address => mapping(address => bool)) public userCollateralEnabled;\n\n\n    // ========== MODIFIERS ==========\n\n    modifier onlyConfigurator() {\n        if (msg.sender != address(configurator)) revert ErrorsLib.OnlyPoolConfigurator();\n        _;\n    }\n\n    modifier onlyPoolAdmin() {\n        if (!aclManager.isPoolAdmin(msg.sender)) revert ErrorsLib.OnlyPoolAdmin();\n        _;\n    }\n\n    modifier onlyEmergencyAdmin() {\n        if (!(aclManager.isEmergencyAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender))) revert ErrorsLib.OnlyEmergencyAdmin();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused) revert ErrorsLib.ProtocolPaused();\n        _;\n    }\n\n    modifier onlyActiveReserve(address asset) {\n        if (!reserves[asset].active) revert ErrorsLib.ReserveNotActive();\n        _;\n    }\n\n    modifier onlyBorrowingEnabled(address asset) {\n        if (!reserves[asset].borrowingEnabled) revert ErrorsLib.BorrowingNotEnabled();\n        _;\n    }\n\n    // ========== CONSTRUCTOR ==========\n\n    constructor(address _aclManager, address _configurator, address _priceOracle) {\n        if (_aclManager == address(0)) revert ErrorsLib.ZeroAddress();\n        if (_configurator == address(0)) revert ErrorsLib.ZeroAddress();\n        if (_priceOracle == address(0)) revert ErrorsLib.ZeroAddress();\n\n        aclManager = ACLManager(_aclManager);\n        configurator = IConfidentialPoolConfigurator(_configurator);\n        priceOracle = IPriceOracle(_priceOracle);\n        paused = false;\n    }\n\n    // ========== CONFIGURATION FUNCTIONS ==========\n\n    function setConfigurator(address _configurator) external onlyPoolAdmin {\n        if (_configurator == address(0)) revert ErrorsLib.ZeroAddress();\n        configurator = IConfidentialPoolConfigurator(_configurator);\n    }\n\n    function setPriceOracle(address _priceOracle) external onlyPoolAdmin {\n        if (_priceOracle == address(0)) revert ErrorsLib.ZeroAddress();\n        priceOracle = IPriceOracle(_priceOracle);\n    }\n\n    function setCollateralAsset(address _ceth) external onlyPoolAdmin {\n        if (!reserves[_ceth].isCollateral) revert ErrorsLib.ReserveNotCollateral();\n        cethAddress = _ceth;\n    }\n\n    // ========== EMERGENCY FUNCTIONS ==========\n\n    event ProtocolPaused(address indexed admin, uint64 timestamp);\n    event ProtocolUnpaused(address indexed admin, uint64 timestamp);\n\n    function pause() external onlyEmergencyAdmin {\n        if (paused) revert ErrorsLib.ProtocolAlreadyPaused();\n        paused = true;\n        emit ProtocolPaused(msg.sender, uint64(block.timestamp));\n    }\n\n    function unpause() external onlyEmergencyAdmin {\n        if (!paused) revert ErrorsLib.ProtocolNotPaused();\n        paused = false;\n        emit ProtocolUnpaused(msg.sender, uint64(block.timestamp));\n    }\n\n    // ========== USER OPERATIONS ==========\n\n    function supply(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof\n    ) external override nonReentrant whenNotPaused onlyActiveReserve(asset) {\n\n        _userSuppliedBalances[msg.sender][asset] = SupplyLogic.executeSupply(\n            asset,\n            amount,\n            inputProof,\n            reserves[asset],\n            _userSuppliedBalances[msg.sender][asset],\n            _userPositions[msg.sender]\n        );\n        emit Supply(asset, msg.sender);\n    }\n\n    function withdraw(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof\n    ) external override nonReentrant whenNotPaused onlyActiveReserve(asset) {\n\n        Types.WithdrawParams memory params;\n        params.asset = asset;\n        params.userBalance = _userSuppliedBalances[msg.sender][asset];\n        params.inputProof = inputProof;\n        params.user = msg.sender;\n        params.withdrawAmount = FHE.fromExternal(amount, inputProof);\n\n        if (asset == cethAddress && userCollateralEnabled[msg.sender][cethAddress]) {\n            _executeWithdrawCollateral(params);\n        } else {\n            ebool IsSafe = params.withdrawAmount.le(params.userBalance);\n            euint64 safeWithdrawAmount = FHE.select(IsSafe, params.withdrawAmount, FHE.asEuint64(0));\n            _finalizeWithdrawal(params, safeWithdrawAmount);\n        }\n    }\n\n    function _executeWithdrawCollateral(Types.WithdrawParams memory params) internal {\n         euint64 withdrawAmount = params.withdrawAmount;\n         euint64 currentSupplied = params.userBalance;\n         euint64 totalDebtUSD = _getAccountDebtUSD(params.user);\n         uint64 collateralPrice = uint64(priceOracle.getPrice(cethAddress));\n\n         require(collateralPrice > 0, \"ORACLE_PRICE_ZERO\");\n\n         euint64 margin = currentSupplied.safeSub(withdrawAmount);\n         euint64 marginUSD = AssetUtils64.getUsdValue64(margin, collateralPrice);\n         ebool isValid = FHE.le(totalDebtUSD, marginUSD);\n         euint64 safeWithdrawAmount = FHE.select(isValid, withdrawAmount, FHE.asEuint64(0));\n\n         _finalizeWithdrawal(params, safeWithdrawAmount);\n    }\n\n    function _finalizeWithdrawal(Types.WithdrawParams memory params, euint64 withdrawAmount) internal {\n        _userSuppliedBalances[params.user][params.asset] = SupplyLogic.executeWithdraw(\n            params.asset,\n            withdrawAmount,\n            reserves[params.asset],\n            params.userBalance,\n            params.user\n        );\n        emit Withdraw(params.asset, params.user);\n    }\n\n\n    function borrow(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof\n    ) external override nonReentrant whenNotPaused onlyActiveReserve(asset) onlyBorrowingEnabled(asset) {\n\n        if (!userCollateralEnabled[msg.sender][cethAddress]) revert ErrorsLib.NoCollateralEnabled();\n        Types.ConfidentialUserPosition storage up = _userPositions[msg.sender];\n        if (up.currentDebtAsset != address(0) && up.currentDebtAsset != asset) {\n            revert ErrorsLib.MultipleDebtsNotAllowed();\n        }\n\n        euint64 borrowingPowerUSD = _getAccountBorrowPowerUSD(msg.sender);\n\n        Types.ConfidentialReserve storage borrowReserve = reserves[asset];\n        uint64 borrowPrice = uint64(priceOracle.getPrice(asset));\n        if (borrowPrice == 0) revert ErrorsLib.OraclePriceZero();\n\n        euint64 requestedAmount = FHE.fromExternal(amount, inputProof);\n        euint64 currentDebtBalance = _userBorrowedBalances[msg.sender][asset];\n\n        euint64 currentDebtUSD = FHE.asEuint64(0);\n        if (up.currentDebtAsset == asset) {\n             currentDebtUSD = AssetUtils64.getUsdValue64(currentDebtBalance, borrowPrice);\n        }\n\n        euint64 requestedAmountUSD = AssetUtils64.getUsdValue64(requestedAmount, borrowPrice);\n        euint64 newTotalDebtUSD = currentDebtUSD.safeAdd(requestedAmountUSD);\n\n        ebool isValid = FHE.le(newTotalDebtUSD, borrowingPowerUSD);\n        euint64 maxSafeBorrow = FHE.select(isValid, requestedAmount, FHE.asEuint64(0));\n\n        euint64 newDebtBalance = BorrowLogic.executeBorrow(\n            asset,\n            maxSafeBorrow,\n            borrowReserve,\n            currentDebtBalance, \n            up,\n            msg.sender\n        );\n        _userBorrowedBalances[msg.sender][asset] = newDebtBalance;\n\n        if (up.currentDebtAsset == address(0)) {\n             up.currentDebtAsset = asset;\n        }\n\n        emit Borrow(asset, msg.sender);\n    }\n\n    /**\n     * @notice Repay logic - Calls BorrowLogic\n     * @param asset The address of the asset to repay.\n     * @param amount The encrypted amount (normalized to 6 decimals) to repay.\n     * @param inputProof FHEVM input proof for the encrypted amount.\n     * @param isRepayingAll A public bool to signal intent to clear the debt.\n     * If true, the function will clear the user's debt asset\n     * but will REVERT if the 'amount' is less than the total debt.\n     */\n    function repay(\n        address asset,\n        externalEuint64 amount,\n        bytes calldata inputProof,\n        bool isRepayingAll \n    ) external override nonReentrant whenNotPaused onlyActiveReserve(asset) {\n        Types.ConfidentialUserPosition storage up = _userPositions[msg.sender];\n        if (!(asset == up.currentDebtAsset || up.currentDebtAsset == address(0))) revert ErrorsLib.InvalidDebtRepayment();\n\n        euint64 payAmount = FHE.fromExternal(amount, inputProof);\n        euint64 userDebt = _userBorrowedBalances[msg.sender][asset];\n\n        euint64 safePayAmount;\n        \n        if (isRepayingAll) {\n            ebool isSafe = FHE.le(payAmount, userDebt);\n            safePayAmount = FHE.select(isSafe,payAmount, userDebt);\n        } else {\n            ebool isOverpaying = payAmount.gt(userDebt);\n            safePayAmount = FHE.select(isOverpaying, userDebt, payAmount);\n        }\n\n        euint64 newDebtBalance = BorrowLogic.executeRepay(\n            asset,\n            safePayAmount,\n            reserves[asset],\n            userDebt\n        );\n\n        _userBorrowedBalances[msg.sender][asset] = newDebtBalance;\n        if (isRepayingAll) {\n            up.currentDebtAsset = address(0);\n        }\n        emit Repay(asset, msg.sender);\n    }\n\n\n    // ========== VIEW FUNCTIONS ==========\n    function getUserSuppliedBalance(address user, address asset) external view override(IConfidentialLendingPool, IConfidentialLendingPoolView) returns (euint64) {\n        return _userSuppliedBalances[user][asset];\n    }\n    function getUserBorrowedBalance(address user, address asset) external view override(IConfidentialLendingPool, IConfidentialLendingPoolView) returns (euint64) {\n        return _userBorrowedBalances[user][asset];\n    }\n    function getUserPosition(address user) external view override(IConfidentialLendingPool, IConfidentialLendingPoolView) returns (Types.ConfidentialUserPosition memory) {\n        return _userPositions[user];\n    }\n    function getReserveData(address asset) external view override returns (Types.ConfidentialReserve memory) {\n        return reserves[asset];\n    }\n    function getReserveList() external view override returns (address[] memory) {\n        return reserveList;\n    }\n\n    // ========== COLLATERAL TOGGLE ==========\n    event UserCollateralChanged(address indexed user, address indexed asset, bool useAsCollateral);\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external whenNotPaused onlyActiveReserve(asset) {\n        if (asset != cethAddress) revert ErrorsLib.NotTheDesignatedCollateral();\n        if (!reserves[asset].isCollateral) revert ErrorsLib.ReserveNotCollateral();\n        userCollateralEnabled[msg.sender][asset] = useAsCollateral;\n        emit UserCollateralChanged(msg.sender, asset, useAsCollateral);\n    }\n\n    // ========== INTERNAL CONFIGURATION ==========\n    function initReserve(\n        address asset,\n        bool borrowingEnabled,\n        bool isCollateral,\n        uint64 collateralFactor\n    ) external onlyConfigurator {\n        if (reserves[asset].underlyingAsset != address(0)) revert ErrorsLib.ReserveAlreadyInitialized();\n\n        Types.ConfidentialReserve storage reserve = reserves[asset];\n        reserve.underlyingAsset = asset;\n        reserve.totalSupplied = FHE.asEuint64(0);\n        reserve.totalBorrowed = FHE.asEuint64(0);\n        reserve.availableLiquidity = FHE.asEuint64(0);\n        reserve.lastUpdateTimestamp = uint64(block.timestamp);\n        reserve.active = true;\n        reserve.borrowingEnabled = borrowingEnabled;\n        reserve.isCollateral = isCollateral;\n        reserve.isPaused = false;\n        reserve.collateralFactor = collateralFactor;\n        reserve.supplyCap = 0;\n        reserve.borrowCap = 0;\n        reserve.decimals = ConfidentialFungibleToken(asset).decimals();\n\n        FHE.makePubliclyDecryptable(reserve.totalSupplied);\n        FHE.makePubliclyDecryptable(reserve.totalBorrowed);\n        FHE.makePubliclyDecryptable(reserve.availableLiquidity);\n\n        reserveList.push(asset);\n    }\n\n    function updateReserveConfig(\n        address asset,\n        bool active,\n        bool borrowingEnabled,\n        bool isCollateral,\n        uint64 collateralFactor,\n        uint64 supplyCap,\n        uint64 borrowCap\n    ) external onlyConfigurator {\n        if (reserves[asset].underlyingAsset == address(0)) revert ErrorsLib.ReserveNotInitialized();\n        Types.ConfidentialReserve storage reserve = reserves[asset];\n        reserve.active = active;\n        reserve.borrowingEnabled = borrowingEnabled;\n        reserve.isCollateral = isCollateral;\n        reserve.collateralFactor = collateralFactor;\n        reserve.supplyCap = supplyCap;\n        reserve.borrowCap = borrowCap;\n    }\n\n   // ========== INTERNAL HEALTH CALCULATION ==========\n\n   function _getAccountBorrowPowerUSD(address user) internal returns (euint64 borrowPowerUSD){\n        borrowPowerUSD = FHE.asEuint64(0);          \n        if (userCollateralEnabled[user][cethAddress]) {\n            Types.ConfidentialReserve storage r = reserves[cethAddress];\n            uint64 price = uint64(priceOracle.getPrice(cethAddress));\n            if (r.active && r.isCollateral && price > 0) {\n                euint64 balance = _userSuppliedBalances[user][cethAddress];\n                euint64 balanceUSD = AssetUtils64.getUsdValue64(balance, price);\n                borrowPowerUSD = balanceUSD.safeMul(r.collateralFactor).safeDiv(10000);\n            }\n        }\n    }\n\n   function _getAccountDebtUSD(address user)\n        internal\n        returns (euint64 totalDebtUSD)\n    {\n        totalDebtUSD = FHE.asEuint64(0);\n        Types.ConfidentialUserPosition storage up = _userPositions[user];\n        address debtAsset = up.currentDebtAsset;\n\n        if (debtAsset != address(0)) {\n            Types.ConfidentialReserve storage r = reserves[debtAsset];\n            uint64 price = uint64(priceOracle.getPrice(debtAsset));\n            if (r.active && price > 0) {\n                 euint64 debtBalance = _userBorrowedBalances[user][debtAsset];\n                 totalDebtUSD = AssetUtils64.getUsdValue64(debtBalance, price);\n            }\n        }\n    }\n\n    // ========== OTHER HELPERS ==========\n    function _hasAnyCollateralEnabled(address user) internal view returns (bool) {\n       return userCollateralEnabled[user][cethAddress];\n    }\n}\n"
    },
    "contracts/protocol/ConfidentialPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IConfidentialPoolConfigurator} from \"../interfaces/IConfidentialPoolConfigurator.sol\";\nimport {IConfidentialLendingPool} from \"../interfaces/IConfidentialLendingPool.sol\";\nimport {IACLManager} from \"../interfaces/IACLManager.sol\";\nimport {Types} from \"../libraries/Types.sol\";\nimport {Constants} from \"../config/Constants.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {FHE} from \"@fhevm/solidity/lib/FHE.sol\";\n\ncontract ConfidentialPoolConfigurator is IConfidentialPoolConfigurator, Ownable {\n\n    IACLManager public immutable aclManager;\n    IConfidentialLendingPool public lendingPool;\n    \n    // Reserve configuration storage\n    mapping(address => Types.ConfidentialReserve) public reserves;\n\n    modifier onlyPoolAdmin() {\n        require(aclManager.isPoolAdmin(msg.sender), \"Only pool admin\");\n        _;\n    }\n\n    modifier onlyRiskAdmin() {\n        require(aclManager.isRiskAdmin(msg.sender), \"Only risk admin\");\n        _;\n    }\n\n    constructor(address _aclManager) Ownable(msg.sender) {\n        aclManager = IACLManager(_aclManager);\n    }\n\n    function setLendingPool(address _lendingPool) external onlyPoolAdmin {\n        lendingPool = IConfidentialLendingPool(_lendingPool);\n    }\n\n    function initReserve(\n        address asset,\n        bool borrowingEnabled,\n        bool isCollateral,\n        uint64 collateralFactor\n    ) external override onlyPoolAdmin {\n        require(address(lendingPool) != address(0), \"Lending pool not set\");\n        require(reserves[asset].underlyingAsset == address(0), \"Reserve already initialized\");\n        if (isCollateral) {\n            require(collateralFactor > 0 && collateralFactor <= Constants.PERCENT_PRECISION, \"Invalid collateral factor for collateral asset\");\n        } else {\n            require(collateralFactor == 0, \"Collateral factor must be 0 for non-collateral asset\");\n        }\n\n        reserves[asset].underlyingAsset = asset;\n        reserves[asset].lastUpdateTimestamp = uint64(block.timestamp);\n        reserves[asset].active = true;\n        reserves[asset].borrowingEnabled = borrowingEnabled;\n        reserves[asset].isCollateral = isCollateral;\n        reserves[asset].isPaused = false;\n        reserves[asset].collateralFactor = collateralFactor;\n        reserves[asset].supplyCap = 0;\n        reserves[asset].borrowCap = 0;\n\n        lendingPool.initReserve(asset, borrowingEnabled, isCollateral, collateralFactor);\n\n        emit ReserveInitialized(asset, borrowingEnabled, isCollateral);\n    }\n\n    function setReserveActive(address asset, bool active) external override onlyPoolAdmin {\n        Types.ConfidentialReserve storage r = reserves[asset];\n        r.active = active;\n        _syncToLendingPool(asset);\n        emit ReserveActiveChanged(asset, active);\n    }\n\n    function setReserveBorrowing(address asset, bool enabled) external override onlyPoolAdmin {\n        Types.ConfidentialReserve storage r = reserves[asset];\n        r.borrowingEnabled = enabled;\n        _syncToLendingPool(asset);\n        emit ReserveBorrowingChanged(asset, enabled);\n    }\n\n    function setReserveCollateral(address asset, bool enabled) external override onlyPoolAdmin {\n        Types.ConfidentialReserve storage r = reserves[asset];\n        r.isCollateral = enabled;\n        _syncToLendingPool(asset);\n        emit ReserveCollateralChanged(asset, enabled);\n    }\n\n    function setCollateralFactor(address asset, uint64 factor) external override onlyRiskAdmin {\n        require(factor <= Constants.VALUE_PRECISION_FACTOR, \"Invalid collateral factor\");\n        Types.ConfidentialReserve storage r = reserves[asset];\n        r.collateralFactor = factor;\n        _syncToLendingPool(asset);\n        emit CollateralFactorUpdated(asset, factor);\n    }\n\n    function getReserveConfig(address asset) external view returns (Types.ConfidentialReserve memory) {\n        return reserves[asset];\n    }\n\n    function setSupplyCap(address asset, uint64 cap) external onlyRiskAdmin {\n        Types.ConfidentialReserve storage r = reserves[asset];\n        r.supplyCap = cap;\n        _syncToLendingPool(asset);\n        emit SupplyCapUpdated(asset, cap);\n    }\n\n    function setBorrowCap(address asset, uint64 cap) external onlyRiskAdmin {\n        Types.ConfidentialReserve storage r = reserves[asset];\n        r.borrowCap = cap;\n        _syncToLendingPool(asset);\n        emit BorrowCapUpdated(asset, cap);\n    }\n\n    function pauseReserve(address asset) external onlyRiskAdmin {\n        reserves[asset].isPaused = true;\n        emit ReservePaused(asset);\n    }\n\n    function unpauseReserve(address asset) external onlyRiskAdmin {\n        reserves[asset].isPaused = false;\n        emit ReserveUnpaused(asset);\n    }\n\n    function _syncToLendingPool(address asset) internal {\n        Types.ConfidentialReserve storage r = reserves[asset];\n        lendingPool.updateReserveConfig(\n            asset,\n            r.active,\n            r.borrowingEnabled,\n            r.isCollateral,\n            r.collateralFactor,\n            r.supplyCap,\n            r.borrowCap\n        );\n    }\n}\n"
    },
    "contracts/protocol/logic/BorrowLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {Types} from \"../../libraries/Types.sol\";\nimport {ErrorsLib} from \"../../libraries/Errors.sol\";\nimport {Constants} from \"../../config/Constants.sol\";\nimport {SafeFHEOperations} from \"../../libraries/SafeFHEOperations.sol\"; \nimport {SafeMath64} from \"../../libraries/SafeMath64.sol\";\nimport {ConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\";\nimport {FHE, euint64, ebool, externalEuint64} from \"@fhevm/solidity/lib/FHE.sol\";\n\n/**\n * @title BorrowLogic\n * @notice Handles borrow and repayment logic\n * @dev All internal euint64 balances represent amounts normalized to 6 decimals.\n */\nlibrary BorrowLogic {\n    using FHE for euint64;\n    using FHE for ebool;\n    using SafeFHEOperations for euint64;\n    using SafeMath64 for uint64;\n\n    /**\n     * @notice Executes a borrow operation.\n     * @dev Assumes amountE6 input is the final, approved 6-decimal amount. De-normalizes for transfer.\n     * @param asset The address of the asset being borrowed.\n     * @param amount The amount to borrow (normalized to 6 decimals).\n     * @param reserve Storage pointer to the asset's reserve configuration.\n     * @param userBorrowBalance The user's current borrow balance (normalized to 6 decimals).\n     * @param userPosition Storage pointer to the user's position data (used for initialization check).\n     * @param user The address of the user performing the borrow.\n     * @return newUserBorrowBalance The user's new borrow balance (normalized to 6 decimals).\n     */\n    function executeBorrow(\n        address asset,\n        euint64 amount,\n        Types.ConfidentialReserve storage reserve,\n        euint64 userBorrowBalance,\n        Types.ConfidentialUserPosition storage userPosition,\n        address user\n    ) external returns (euint64 newUserBorrowBalance) {\n        if (!reserve.active) revert ErrorsLib.ReserveNotActive();\n        if (!reserve.borrowingEnabled) revert ErrorsLib.BorrowingNotEnabled();\n        if (reserve.isPaused) revert ErrorsLib.ProtocolPaused();\n        if (asset == address(0)) revert ErrorsLib.ZeroAddress();\n\n        euint64 liquidityCappedAmount = amount.validateAndCap(reserve.availableLiquidity);\n\n\n        euint64 maxAllowedBorrow = FHE.asEuint64(Constants.MAX_EUINT64);\n         if (reserve.borrowCap > 0) {\n             euint64 cap = FHE.asEuint64(reserve.borrowCap); \n             euint64 currentTotalBorrowed = reserve.totalBorrowed; \n             euint64 remainingCap = cap.safeSub(currentTotalBorrowed);\n             maxAllowedBorrow = remainingCap;\n         }\n        euint64 finalAmount = liquidityCappedAmount.validateAndCap(maxAllowedBorrow);\n\n        // Initialize user position if needed (cheap operation)\n        if (!userPosition.initialized) {\n            userPosition.initialized = true;\n        }\n\n  \n        newUserBorrowBalance = userBorrowBalance.safeAdd(finalAmount);\n        reserve.totalBorrowed = reserve.totalBorrowed.safeAdd(finalAmount);\n        reserve.availableLiquidity = reserve.availableLiquidity.safeSub(finalAmount);\n\n        FHE.allow(newUserBorrowBalance, user);\n        FHE.allowThis(newUserBorrowBalance);\n        FHE.allowThis(reserve.totalBorrowed);\n        FHE.allowThis(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.totalBorrowed);\n        FHE.makePubliclyDecryptable(reserve.availableLiquidity);\n\n\n        FHE.allowTransient(finalAmount, asset);\n        ConfidentialFungibleToken(asset).confidentialTransfer(user, finalAmount);\n\n        return newUserBorrowBalance;\n    }\n\n    /**\n     * @notice Executes a repay operation.\n     * @dev Assumes payAmount input is the safe 6-decimal amount to repay\n     * @param asset The address of the asset being repaid.\n     * @param payAmount The amount to repay (normalized to 6 decimals, already capped).\n     * @param reserve Storage pointer to the asset's reserve configuration.\n     * @param userBorrowBalance The user's current borrow balance (normalized to 6 decimals).\n     * @return newUserBorrowBalance The user's new borrow balance (normalized to 6 decimals).\n     */\n    function executeRepay(\n        address asset,\n        euint64 payAmount, \n        Types.ConfidentialReserve storage reserve,\n        euint64 userBorrowBalance\n    ) external returns (euint64 newUserBorrowBalance) {\n        if (!reserve.active) revert ErrorsLib.ReserveNotActive();\n        if (asset == address(0)) revert ErrorsLib.ZeroAddress();\n\n        FHE.allowTransient(payAmount, asset);\n        ConfidentialFungibleToken(asset).confidentialTransferFrom(\n            msg.sender,\n            address(this),\n            payAmount\n        );\n\n        newUserBorrowBalance = userBorrowBalance.safeSub(payAmount);\n        reserve.totalBorrowed = reserve.totalBorrowed.safeSub(payAmount);\n        reserve.availableLiquidity = reserve.availableLiquidity.safeAdd(payAmount);\n\n        FHE.allow(newUserBorrowBalance, msg.sender);\n        FHE.allowThis(newUserBorrowBalance);\n        FHE.allowThis(reserve.totalBorrowed);\n        FHE.allowThis(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.totalBorrowed);\n\n        return newUserBorrowBalance;\n    }\n}"
    },
    "contracts/protocol/logic/SupplyLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {FHE, euint64, ebool, externalEuint64, euint128} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {Types} from \"../../libraries/Types.sol\";\nimport {ErrorsLib} from \"../../libraries/Errors.sol\";\nimport {Constants} from \"../../config/Constants.sol\";\nimport {SafeFHEOperations} from \"../../libraries/SafeFHEOperations.sol\";\nimport {SafeMath64} from \"../../libraries/SafeMath64.sol\";\nimport {ConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\";\n\n\nlibrary SupplyLogic {\n    using FHE for euint64;\n    using FHE for ebool;\n    using FHE for euint128;\n    using SafeFHEOperations for euint64;\n    using SafeMath64 for uint64;\n\n    event SupplyExecuted(address indexed user, address indexed asset, uint64 timestamp);\n    event WithdrawExecuted(address indexed user, address indexed asset, uint64 timestamp);\n\n    function executeSupply(\n        address asset,\n        externalEuint64 encryptedAmount,\n        bytes calldata inputProof,\n        Types.ConfidentialReserve storage reserve,\n        euint64 userBalance,\n        Types.ConfidentialUserPosition storage userPosition\n    ) external returns (euint64 newUserBalance) {\n        if (!reserve.active) revert ErrorsLib.ReserveNotActive();\n        if (reserve.isPaused) revert ErrorsLib.ProtocolPaused();\n        if (asset == address(0)) revert ErrorsLib.ZeroAddress();\n\n        euint64 amount = FHE.fromExternal(encryptedAmount, inputProof);\n\n        // --- Supply Cap Check ---\n        euint64 maxAllowedAmount = FHE.asEuint64(Constants.MAX_EUINT64);\n        if (reserve.supplyCap > 0) {\n             euint64 currentTotalSupply = reserve.totalSupplied; \n             euint64 cap = FHE.asEuint64(reserve.supplyCap);\n             euint64 remainingCap = cap.safeSub(currentTotalSupply);\n             maxAllowedAmount = remainingCap;\n        }\n        euint64 finalAmount = amount.validateAndCap(maxAllowedAmount);\n\n        if (!userPosition.initialized) {\n            userPosition.initialized = true;\n        }\n\n        FHE.allowTransient(finalAmount, asset);\n        ConfidentialFungibleToken(asset).confidentialTransferFrom(\n            msg.sender,\n            address(this),\n            finalAmount\n        );\n\n        newUserBalance = userBalance.safeAdd(finalAmount);\n        reserve.totalSupplied = reserve.totalSupplied.safeAdd(finalAmount);\n        reserve.availableLiquidity = reserve.availableLiquidity.safeAdd(finalAmount);\n\n        // Grant ACL permissions\n        FHE.allow(newUserBalance, msg.sender);\n        FHE.allowThis(newUserBalance);\n        FHE.allowThis(reserve.totalSupplied);\n        FHE.allowThis(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.totalSupplied); \n\n        emit SupplyExecuted(msg.sender, asset, uint64(block.timestamp));\n        return newUserBalance;\n    }\n\n\n    function executeWithdraw(\n        address asset,\n        euint64 withdrawAmount,\n        Types.ConfidentialReserve storage reserve,\n        euint64 userBalance,\n        address user\n    ) external returns (euint64 newUserBalance) {\n        if (!reserve.active) revert ErrorsLib.ReserveNotActive();\n        if (reserve.isPaused) revert ErrorsLib.ProtocolPaused();\n        if (asset == address(0)) revert ErrorsLib.ZeroAddress();\n\n        euint64 finalAmount = withdrawAmount.validateAndCap(userBalance);\n\n        newUserBalance = userBalance.safeSub(finalAmount);\n        reserve.totalSupplied = reserve.totalSupplied.safeSub(finalAmount);\n        reserve.availableLiquidity = reserve.availableLiquidity.safeSub(finalAmount);\n\n        // Grant ACL permissions\n        FHE.allow(newUserBalance, user);\n        FHE.allowThis(newUserBalance);\n        FHE.allowThis(reserve.totalSupplied);\n        FHE.allowThis(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.availableLiquidity);\n        FHE.makePubliclyDecryptable(reserve.totalSupplied);\n\n        FHE.allowTransient(finalAmount, asset);\n        ConfidentialFungibleToken(asset).confidentialTransfer(\n            user,\n            finalAmount\n        );\n\n        emit WithdrawExecuted(user, asset, uint64(block.timestamp));\n        return newUserBalance;\n    }\n}"
    },
    "contracts/token/ConfidentialDAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {ConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {FHE, externalEuint64, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title Confidential DAI (cDAI)\n/// @notice ERC7984 confidential version of DAI for private transactions\n/// @dev This is a generic confidential token that can be swapped with DAI via ConfidentialTokenSwapper\ncontract ConfidentialDAI is ConfidentialFungibleToken, Ownable, SepoliaConfig, ReentrancyGuard {\n    // Events\n    event ConfidentialMint(address indexed to, uint256 amount);\n    event ConfidentialBurn(address indexed from, uint256 amount);\n\n    // DAI contract address on Sepolia\n    address public constant DAI_ADDRESS = 0x75236711d42D0f7Ba91E03fdCe0C9377F5b76c07;\n\n    constructor(\n        address owner,\n        string memory name,\n        string memory symbol,\n        string memory uri\n    ) ConfidentialFungibleToken(name, symbol, uri) Ownable(owner) {}\n\n    /// @notice Mint confidential DAI tokens (called by swapper)\n    /// @param to The recipient address\n    /// @param amount The amount to mint (as uint64)\n    function mint(address to, uint64 amount) external {\n        // For now, we'll allow anyone to mint for testing\n        require(to != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        _mint(to, FHE.asEuint64(amount));\n        emit ConfidentialMint(to, amount);\n    }\n\n    /// @notice Burn confidential DAI tokens (called by swapper)\n    /// @param from The address to burn from\n    /// @param amount The encrypted amount to burn\n    function burnFrom(address from, euint64 amount) external returns (euint64 transferred) {\n        require(from != address(0), \"Invalid address\");\n        transferred = _burn(from, amount);\n        \n        emit ConfidentialBurn(from, uint256(euint64.unwrap(transferred)));\n    }\n\n    /// @notice Get the underlying DAI token address\n    /// @return The DAI contract address\n    function underlying() external pure returns (address) {\n        return DAI_ADDRESS;\n    }\n\n    /// @notice Get encrypted balance for a user\n    /// @param user The user address\n    /// @return The encrypted balance\n    function getEncryptedBalance(address user) external view returns (euint64) {\n        return confidentialBalanceOf(user);\n    }\n\n    /// @notice 1:1 conversion rate with DAI\n    /// @return The conversion rate (1)\n    function rate() external pure returns (uint256) {\n        return 1;\n    }\n\n}\n\n"
    },
    "contracts/token/ConfidentialUSDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {ConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {FHE, externalEuint64, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title Confidential USDC (cUSDC)\n/// @notice ERC7984 confidential version of USDC for private transactions\n/// @dev This is a generic confidential token that can be swapped with USDC via ConfidentialTokenSwapper\ncontract ConfidentialUSDC is ConfidentialFungibleToken, Ownable, SepoliaConfig, ReentrancyGuard {\n    // Events\n    event ConfidentialMint(address indexed to, uint256 amount);\n    event ConfidentialBurn(address indexed from, uint256 amount);\n\n    // USDC contract address on Sepolia\n    address public constant USDC_ADDRESS = 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238;\n\n    constructor(\n        address owner,\n        string memory name,\n        string memory symbol,\n        string memory uri\n    ) ConfidentialFungibleToken(name, symbol, uri) Ownable(owner) {}\n\n    /// @notice Mint confidential USDC tokens (called by swapper)\n    /// @param to The recipient address\n    /// @param amount The amount to mint (as uint64)\n    function mint(address to, uint64 amount) external {\n        // For now, we'll allow anyone to mint for testing\n        require(to != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        _mint(to, FHE.asEuint64(amount));\n        emit ConfidentialMint(to, amount);\n    }\n\n    /// @notice Burn confidential USDC tokens (called by swapper)\n    /// @param from The address to burn from\n    /// @param amount The encrypted amount to burn\n    function burnFrom(address from, euint64 amount) external returns (euint64 transferred) {\n        require(from != address(0), \"Invalid address\");\n        transferred = _burn(from, amount);\n\n        emit ConfidentialBurn(from, uint256(euint64.unwrap(transferred)));\n    }\n\n    /// @notice Get the underlying USDC token address\n    /// @return The USDC contract address\n    function underlying() external pure returns (address) {\n        return USDC_ADDRESS;\n    }\n\n    /// @notice Get encrypted balance for a user\n    /// @param user The user address\n    /// @return The encrypted balance\n    function getEncryptedBalance(address user) external view returns (euint64) {\n        return confidentialBalanceOf(user);\n    }\n\n    /// @notice 1:1 conversion rate with USDC\n    /// @return The conversion rate (1)\n    function rate() external pure returns (uint256) {\n        return 1;\n    }\n\n}\n"
    },
    "contracts/token/ConfidentialWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {ConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/token/ConfidentialFungibleToken.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {FHE, externalEuint64, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title Confidential WETH (cWETH)\n/// @notice ERC7984 confidential version of WETH for private transactions\n/// @dev This is a generic confidential token that can be swapped with WETH via ConfidentialTokenSwapper\ncontract ConfidentialWETH is ConfidentialFungibleToken, Ownable, SepoliaConfig, ReentrancyGuard {\n    // Events\n    event ConfidentialMint(address indexed to, uint256 amount);\n    event ConfidentialBurn(address indexed from, uint256 amount);\n\n    // WETH contract address on Sepolia\n    address public constant WETH_ADDRESS = 0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9;\n\n    constructor(\n        address owner,\n        string memory name,\n        string memory symbol,\n        string memory uri\n    ) ConfidentialFungibleToken(name, symbol, uri) Ownable(owner) {}\n\n    /// @notice Mint confidential WETH tokens (called by swapper)\n    /// @param to The recipient address\n    /// @param amount The amount to mint (as uint64)\n    function mint(address to, uint64 amount) external {\n        // For now, we'll allow anyone to mint for testing\n        require(to != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        _mint(to, FHE.asEuint64(amount));\n        emit ConfidentialMint(to, amount);\n    }\n\n    /// @notice Burn confidential WETH tokens (called by swapper)\n    /// @param from The address to burn from\n    /// @param amount The encrypted amount to burn\n    function burnFrom(address from, euint64 amount) external returns (euint64 transferred) {\n        require(from != address(0), \"Invalid address\");\n        transferred = _burn(from, amount);\n        \n        emit ConfidentialBurn(from, uint256(euint64.unwrap(transferred)));\n    }\n\n    /// @notice Get the underlying WETH token address\n    /// @return The WETH contract address\n    function underlying() external pure returns (address) {\n        return WETH_ADDRESS;\n    }\n\n    /// @notice Get encrypted balance for a user\n    /// @param user The user address\n    /// @return The encrypted balance\n    function getEncryptedBalance(address user) external view returns (euint64) {\n        return confidentialBalanceOf(user);\n    }\n\n    /// @notice 1:1 conversion rate with WETH\n    /// @return The conversion rate (1)\n    function rate() external pure returns (uint256) {\n        return 1;\n    }\n\n}"
    },
    "contracts/token/swapper/ConfidentialTokenSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {IConfidentialFungibleToken} from \"@openzeppelin/confidential-contracts/interfaces/IConfidentialFungibleToken.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FHE, externalEuint64, euint64} from \"@fhevm/solidity/lib/FHE.sol\";\nimport {SepoliaConfig} from \"@fhevm/solidity/config/ZamaConfig.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title ERC20 <-> ERC7984 Token Swapper\ncontract ConfidentialTokenSwapper is Ownable, SepoliaConfig, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // --- Constants ---\n    uint64 private constant INTERNAL_DECIMALS_FACTOR = 10**6;\n\n    // --- Errors ---\n    error InvalidTokenPair();\n    error InsufficientBalance();\n    error InvalidAmount();\n    error InvalidRecipient();\n    error InvalidGatewayRequest(uint256 requestId);\n    error AmountExceedsUint64(); \n\n    // --- Events---\n    event ERC20ToConfidentialSwap(address indexed user, address indexed erc20, uint256 amount, address indexed confidential);\n    event ConfidentialToERC20SwapInitiated(address indexed user, address indexed confidential, uint256 requestId, address indexed erc20);\n    event ConfidentialToERC20SwapFinalized(address indexed user, uint256 requestId, uint64 amount, address indexed erc20); \n\n    // --- State Variables---\n    mapping(address => address) private _erc20ToConfidential;\n    mapping(address => address) private _confidentialToErc20;\n    mapping(address => bool) private _supportedTokens;\n    mapping(uint256 requestId => address) private _receivers;\n    mapping(uint256 requestId => address) private _erc20Tokens;\n\n    // --- Constructor---\n    constructor(address owner_) Ownable(owner_) {}\n\n    // ------------------------------------------------------------\n    //  Admin\n    // ------------------------------------------------------------\n    function addTokenPair(address erc20Token, address confidentialToken) external onlyOwner {\n        require(erc20Token != address(0) && confidentialToken != address(0), \"Invalid address\");\n        _erc20ToConfidential[erc20Token] = confidentialToken;\n        _confidentialToErc20[confidentialToken] = erc20Token;\n        _supportedTokens[erc20Token] = true; \n    }\n\n    function removeTokenPair(address erc20Token) external onlyOwner {\n        address conf = _erc20ToConfidential[erc20Token];\n        require(conf != address(0), \"Pair not found\"); \n        delete _erc20ToConfidential[erc20Token];\n        delete _confidentialToErc20[conf];\n        delete _supportedTokens[erc20Token]; \n    }\n\n    // -------------------------------------------------\n    //  ERC20 -> Confidential\n    // -------------------------------------------------\n    function swapERC20ToConfidential(\n        address erc20Token,\n        uint256 nativeAmount,\n        address to\n    ) external nonReentrant {\n        if (!_supportedTokens[erc20Token]) revert InvalidTokenPair();\n        if (nativeAmount == 0) revert InvalidAmount();\n        if (to == address(0)) revert InvalidRecipient();\n        address confToken = _erc20ToConfidential[erc20Token];\n\n        uint8 nativeDecimals = IERC20Metadata(erc20Token).decimals();\n        uint256 amountE6_uint256;\n        if (nativeDecimals == 6) {\n             amountE6_uint256 = nativeAmount;\n        } else if (nativeDecimals > 6) {\n            uint256 scalingFactor = 10**uint256(nativeDecimals - 6);\n            amountE6_uint256 = nativeAmount / scalingFactor;\n        } else {\n            uint256 scalingFactor = 10**uint256(6 - nativeDecimals);\n            amountE6_uint256 = nativeAmount * scalingFactor;\n        }\n        require(amountE6_uint256 > 0 || nativeAmount == 0, \"Amount too small\");\n        if (amountE6_uint256 > type(uint64).max) {\n             revert AmountExceedsUint64();\n        }\n        uint64 amountE6 = uint64(amountE6_uint256);\n        IERC20(erc20Token).safeTransferFrom(msg.sender, address(this), nativeAmount);\n\n        (bool success, bytes memory returnData) = confToken.call(\n            abi.encodeWithSignature(\"mint(address,uint64)\", to, amountE6));\n        require(success, string(abi.encodePacked(\"Mint failed: \", returnData))); \n\n        emit ERC20ToConfidentialSwap(msg.sender, erc20Token, nativeAmount, confToken);\n    }\n\n    // ----------------------------------------------\n    //  Confidential -> ERC20\n    // ----------------------------------------------\n    function swapConfidentialToERC20(\n        address confToken,\n        externalEuint64 encryptedAmountE6, \n        bytes calldata inputProof\n    ) external nonReentrant returns (uint256 requestId) {\n        address erc20Token = _confidentialToErc20[confToken];\n        if (erc20Token == address(0)) revert InvalidTokenPair();\n\n        euint64 amountE6 = FHE.fromExternal(encryptedAmountE6, inputProof);\n\n        FHE.allowTransient(amountE6, confToken);\n\n        euint64 amountTransferredE6 = IConfidentialFungibleToken(confToken).confidentialTransferFrom(\n            msg.sender,\n            address(this),\n            amountE6\n        );\n\n        bytes32[] memory cts = new bytes32[](1);\n        cts[0] = euint64.unwrap(amountTransferredE6);\n        requestId = FHE.requestDecryption(cts, this.finalizeSwap.selector);\n\n        _receivers[requestId] = msg.sender;\n        _erc20Tokens[requestId] = erc20Token;\n\n        emit ConfidentialToERC20SwapInitiated(msg.sender, confToken, requestId, erc20Token);\n    }\n\n    // ------------------------------------------------------------\n    //  Gateway Callback \n    // ------------------------------------------------------------\n    function finalizeSwap(\n        uint256 requestId,\n        bytes calldata cleartexts,\n        bytes calldata decryptionProof\n    ) public virtual {\n        \n        FHE.checkSignatures(requestId, cleartexts, decryptionProof);\n        uint64 decryptedAmountE6 = abi.decode(cleartexts, (uint64));\n        address to = _receivers[requestId];\n        if (to == address(0)) revert InvalidGatewayRequest(requestId);\n        address erc20Token = _erc20Tokens[requestId]; \n        delete _receivers[requestId];\n        delete _erc20Tokens[requestId]; \n\n        // Calculate Native ERC20 Amount\n        uint256 nativeAmount = 0;\n        if (decryptedAmountE6 != 0) {\n            uint8 nativeDecimals = IERC20Metadata(erc20Token).decimals();\n            if (nativeDecimals == 6) {\n                nativeAmount = uint256(decryptedAmountE6);\n            } else if (nativeDecimals > 6) {\n                uint256 scalingFactor = 10**uint256(nativeDecimals - 6);\n                nativeAmount = uint256(decryptedAmountE6) * scalingFactor;\n            } else {\n                uint256 scalingFactor = 10**uint256(6 - nativeDecimals);\n                nativeAmount = uint256(decryptedAmountE6) / scalingFactor;\n            }\n            require(nativeAmount > 0 || decryptedAmountE6 == 0, \"Amount became zero\");\n        }\n\n        if (nativeAmount > 0) { \n            uint256 contractBalance = IERC20(erc20Token).balanceOf(address(this));\n            if (contractBalance < nativeAmount) revert InsufficientBalance();\n            IERC20(erc20Token).safeTransfer(to, nativeAmount);\n        }\n\n        emit ConfidentialToERC20SwapFinalized(to, requestId, decryptedAmountE6, erc20Token);\n    }\n\n    // ------------------------------------------------------------\n    //  View Helpers \n    // ------------------------------------------------------------\n    function getConfidentialToken(address erc20Token) external view returns (address) {\n        return _erc20ToConfidential[erc20Token];\n    }\n    function getERC20Token(address confToken) external view returns (address) {\n        return _confidentialToErc20[confToken];\n    }\n    function isTokenSupported(address erc20Token) external view returns (bool) {\n        return _supportedTokens[erc20Token]; \n    }\n    function getPendingSwap(uint256 requestId) external view returns (address receiver, address erc20Token) {\n        return (_receivers[requestId], _erc20Tokens[requestId]);\n    }\n\n    // ------------------------------------------------------------\n    //  Emergency Admin\n    // ------------------------------------------------------------\n    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {\n        IERC20(token).safeTransfer(owner(), amount);\n    }\n}"
    },
    "encrypted-types/EncryptedTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ntype ebool is bytes32;\n\ntype euint8 is bytes32;\ntype euint16 is bytes32;\ntype euint24 is bytes32;\ntype euint32 is bytes32;\ntype euint40 is bytes32;\ntype euint48 is bytes32;\ntype euint56 is bytes32;\ntype euint64 is bytes32;\ntype euint72 is bytes32;\ntype euint80 is bytes32;\ntype euint88 is bytes32;\ntype euint96 is bytes32;\ntype euint104 is bytes32;\ntype euint112 is bytes32;\ntype euint120 is bytes32;\ntype euint128 is bytes32;\ntype euint136 is bytes32;\ntype euint144 is bytes32;\ntype euint152 is bytes32;\ntype euint160 is bytes32;\ntype euint168 is bytes32;\ntype euint176 is bytes32;\ntype euint184 is bytes32;\ntype euint192 is bytes32;\ntype euint200 is bytes32;\ntype euint208 is bytes32;\ntype euint216 is bytes32;\ntype euint224 is bytes32;\ntype euint232 is bytes32;\ntype euint240 is bytes32;\ntype euint248 is bytes32;\ntype euint256 is bytes32;\n\ntype eint8 is bytes32;\ntype eint16 is bytes32;\ntype eint24 is bytes32;\ntype eint32 is bytes32;\ntype eint40 is bytes32;\ntype eint48 is bytes32;\ntype eint56 is bytes32;\ntype eint64 is bytes32;\ntype eint72 is bytes32;\ntype eint80 is bytes32;\ntype eint88 is bytes32;\ntype eint96 is bytes32;\ntype eint104 is bytes32;\ntype eint112 is bytes32;\ntype eint120 is bytes32;\ntype eint128 is bytes32;\ntype eint136 is bytes32;\ntype eint144 is bytes32;\ntype eint152 is bytes32;\ntype eint160 is bytes32;\ntype eint168 is bytes32;\ntype eint176 is bytes32;\ntype eint184 is bytes32;\ntype eint192 is bytes32;\ntype eint200 is bytes32;\ntype eint208 is bytes32;\ntype eint216 is bytes32;\ntype eint224 is bytes32;\ntype eint232 is bytes32;\ntype eint240 is bytes32;\ntype eint248 is bytes32;\ntype eint256 is bytes32;\n\ntype eaddress is bytes32;\n\ntype ebytes1 is bytes32;\ntype ebytes2 is bytes32;\ntype ebytes3 is bytes32;\ntype ebytes4 is bytes32;\ntype ebytes5 is bytes32;\ntype ebytes6 is bytes32;\ntype ebytes7 is bytes32;\ntype ebytes8 is bytes32;\ntype ebytes9 is bytes32;\ntype ebytes10 is bytes32;\ntype ebytes11 is bytes32;\ntype ebytes12 is bytes32;\ntype ebytes13 is bytes32;\ntype ebytes14 is bytes32;\ntype ebytes15 is bytes32;\ntype ebytes16 is bytes32;\ntype ebytes17 is bytes32;\ntype ebytes18 is bytes32;\ntype ebytes19 is bytes32;\ntype ebytes20 is bytes32;\ntype ebytes21 is bytes32;\ntype ebytes22 is bytes32;\ntype ebytes23 is bytes32;\ntype ebytes24 is bytes32;\ntype ebytes25 is bytes32;\ntype ebytes26 is bytes32;\ntype ebytes27 is bytes32;\ntype ebytes28 is bytes32;\ntype ebytes29 is bytes32;\ntype ebytes30 is bytes32;\ntype ebytes31 is bytes32;\ntype ebytes32 is bytes32;\n\ntype externalEbool is bytes32;\n\ntype externalEuint8 is bytes32;\ntype externalEuint16 is bytes32;\ntype externalEuint24 is bytes32;\ntype externalEuint32 is bytes32;\ntype externalEuint40 is bytes32;\ntype externalEuint48 is bytes32;\ntype externalEuint56 is bytes32;\ntype externalEuint64 is bytes32;\ntype externalEuint72 is bytes32;\ntype externalEuint80 is bytes32;\ntype externalEuint88 is bytes32;\ntype externalEuint96 is bytes32;\ntype externalEuint104 is bytes32;\ntype externalEuint112 is bytes32;\ntype externalEuint120 is bytes32;\ntype externalEuint128 is bytes32;\ntype externalEuint136 is bytes32;\ntype externalEuint144 is bytes32;\ntype externalEuint152 is bytes32;\ntype externalEuint160 is bytes32;\ntype externalEuint168 is bytes32;\ntype externalEuint176 is bytes32;\ntype externalEuint184 is bytes32;\ntype externalEuint192 is bytes32;\ntype externalEuint200 is bytes32;\ntype externalEuint208 is bytes32;\ntype externalEuint216 is bytes32;\ntype externalEuint224 is bytes32;\ntype externalEuint232 is bytes32;\ntype externalEuint240 is bytes32;\ntype externalEuint248 is bytes32;\ntype externalEuint256 is bytes32;\n\ntype externalEint8 is bytes32;\ntype externalEint16 is bytes32;\ntype externalEint24 is bytes32;\ntype externalEint32 is bytes32;\ntype externalEint40 is bytes32;\ntype externalEint48 is bytes32;\ntype externalEint56 is bytes32;\ntype externalEint64 is bytes32;\ntype externalEint72 is bytes32;\ntype externalEint80 is bytes32;\ntype externalEint88 is bytes32;\ntype externalEint96 is bytes32;\ntype externalEint104 is bytes32;\ntype externalEint112 is bytes32;\ntype externalEint120 is bytes32;\ntype externalEint128 is bytes32;\ntype externalEint136 is bytes32;\ntype externalEint144 is bytes32;\ntype externalEint152 is bytes32;\ntype externalEint160 is bytes32;\ntype externalEint168 is bytes32;\ntype externalEint176 is bytes32;\ntype externalEint184 is bytes32;\ntype externalEint192 is bytes32;\ntype externalEint200 is bytes32;\ntype externalEint208 is bytes32;\ntype externalEint216 is bytes32;\ntype externalEint224 is bytes32;\ntype externalEint232 is bytes32;\ntype externalEint240 is bytes32;\ntype externalEint248 is bytes32;\ntype externalEint256 is bytes32;\n\ntype externalEaddress is bytes32;\n\ntype externalEbytes1 is bytes32;\ntype externalEbytes2 is bytes32;\ntype externalEbytes3 is bytes32;\ntype externalEbytes4 is bytes32;\ntype externalEbytes5 is bytes32;\ntype externalEbytes6 is bytes32;\ntype externalEbytes7 is bytes32;\ntype externalEbytes8 is bytes32;\ntype externalEbytes9 is bytes32;\ntype externalEbytes10 is bytes32;\ntype externalEbytes11 is bytes32;\ntype externalEbytes12 is bytes32;\ntype externalEbytes13 is bytes32;\ntype externalEbytes14 is bytes32;\ntype externalEbytes15 is bytes32;\ntype externalEbytes16 is bytes32;\ntype externalEbytes17 is bytes32;\ntype externalEbytes18 is bytes32;\ntype externalEbytes19 is bytes32;\ntype externalEbytes20 is bytes32;\ntype externalEbytes21 is bytes32;\ntype externalEbytes22 is bytes32;\ntype externalEbytes23 is bytes32;\ntype externalEbytes24 is bytes32;\ntype externalEbytes25 is bytes32;\ntype externalEbytes26 is bytes32;\ntype externalEbytes27 is bytes32;\ntype externalEbytes28 is bytes32;\ntype externalEbytes29 is bytes32;\ntype externalEbytes30 is bytes32;\ntype externalEbytes31 is bytes32;\ntype externalEbytes32 is bytes32;\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}